<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Apparato cardiocircolatorio & Sistema nervoso — Presentazione 3D (offline-ready)</title>

  <!--
    OFFLINE (consigliato per davvero):
    Opzione A (semplice): lascia importmap su CDN (serve internet).
    Opzione B (offline): scarica e metti nella stessa cartella:
      - three.module.js
      - OrbitControls.js  (versione "jsm")
    Poi cambia importmap così:
      "three": "./three.module.js",
      "three/addons/": "./addons/"
    e metti OrbitControls in ./addons/controls/OrbitControls.js
  -->

  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1833cc;
      --text:#e8eeff;
      --muted:#a9b6e6;
      --accent:#67d5ff;
      --accent2:#a6ffcb;
      --danger:#ff5c7a;
      --shadow: 0 12px 30px rgba(0,0,0,.45);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 900px at 20% 10%, #192b66 0%, var(--bg) 55%, #060a14 100%); color: var(--text); font-family: var(--font); overflow: hidden; }

    .app{
      height:100%;
      display:grid;
      grid-template-columns: 310px 1fr;
      gap: 14px;
      padding: 14px;
    }

    .sidebar{
      background: linear-gradient(180deg, rgba(15,24,51,.82), rgba(10,16,34,.86));
      border: 1px solid rgba(103,213,255,.16);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction: column;
      overflow:hidden;
      min-width: 260px;
    }

    .brand{
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    .brand h1{ font-size: 15px; margin: 0 0 6px 0; letter-spacing: .3px; font-weight: 750; }
    .brand p{ margin: 0; font-size: 12.5px; color: var(--muted); line-height: 1.35; }

    .nav{ padding: 10px; display: grid; gap: 8px; overflow:auto; }
    .nav button{
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      text-align:left;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      outline: none;
    }
    .nav button:hover{ transform: translateY(-1px); border-color: rgba(103,213,255,.28); background: rgba(103,213,255,.08); }
    .nav button.active{ border-color: rgba(103,213,255,.50); background: rgba(103,213,255,.14); box-shadow: 0 0 0 1px rgba(103,213,255,.08) inset; }
    .nav .title{ font-weight: 700; font-size: 13.5px; margin-bottom: 2px; }
    .nav .desc{ font-size: 12px; color: var(--muted); line-height: 1.35; }

    .controls{
      margin-top: auto;
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.18));
    }
    .row{ display:flex; gap: 8px; align-items:center; flex-wrap: wrap; margin-bottom: 10px; }
    .row:last-child{ margin-bottom: 0; }

    .btn{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 9px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: background .12s ease, transform .12s ease, border-color .12s ease;
      font-size: 12.5px;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.09); border-color: rgba(103,213,255,.25); }
    .btn.primary{ border-color: rgba(103,213,255,.40); background: rgba(103,213,255,.16); }
    .btn.danger{ border-color: rgba(255,92,122,.45); background: rgba(255,92,122,.12); }
    .btn.toggleOn{ border-color: rgba(166,255,203,.55); background: rgba(166,255,203,.14); }

    .slider{
      flex: 1;
      min-width: 140px;
      display:flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 12px;
    }
    .slider label{ font-size: 11.5px; color: var(--muted); display:flex; justify-content: space-between; gap: 10px; }
    .slider input[type="range"]{ width: 100%; }
    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(180deg, rgba(103,213,255,1), rgba(78,160,255,1));
      border: 1px solid rgba(255,255,255,.35);
      box-shadow: 0 8px 18px rgba(103,213,255,.25);
      cursor: pointer;
    }

    .main{
      position: relative;
      border-radius: var(--radius);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: var(--shadow);
      background: rgba(0,0,0,.18);
      min-width: 0;
    }
    canvas{ display:block; width:100%; height:100%; }

    .hud{ position:absolute; inset: 0; pointer-events: none; display:flex; flex-direction: column; justify-content: space-between; }
    .topbar{ padding: 12px; display:flex; align-items:flex-start; justify-content: space-between; gap: 10px; }

    .panel{
      pointer-events: auto;
      background: rgba(15,24,51,.70);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 12px;
      max-width: 520px;
      backdrop-filter: blur(10px);
    }
    .panel h2{ margin: 0 0 6px 0; font-size: 16px; letter-spacing: .2px; }
    .panel p{ margin: 0; color: var(--muted); font-size: 12.5px; line-height: 1.45; }

    .mini{
      pointer-events: auto;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
      width: 280px;
    }
    .mini .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      font-family: var(--mono);
    }
    .mini .kv b{ color: var(--text); font-family: var(--font); font-size: 12px; }

    .bottombar{ padding: 12px; display:flex; gap: 10px; align-items:flex-end; justify-content: space-between; pointer-events: none; }

    .legend{
      pointer-events:auto;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
      max-width: 520px;
    }
    .chips{ display:flex; flex-wrap: wrap; gap: 8px; }
    .chip{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      font-size: 12px;
      color: var(--muted);
    }
    .dot{ width:10px; height:10px; border-radius:50%; box-shadow: 0 0 0 2px rgba(255,255,255,.12) inset; }

    .toast{
      pointer-events:auto;
      display:none;
      align-items:center;
      gap: 10px;
      background: rgba(15,24,51,.78);
      border:  1px solid rgba(103,213,255,.18);
      border-radius: 14px;
      padding: 10px 12px;
      max-width: 380px;
    }
    .toast.show{ display:flex; }
    .toast .hint{ font-size: 12.5px; color: var(--muted); line-height: 1.35; }

    .labelLayer{ position:absolute; inset: 0; pointer-events: none; overflow: hidden; }
    .label{
      position:absolute;
      transform: translate(-50%, -50%);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 12px;
      color: rgba(255,255,255,.92);
      background: rgba(15,24,51,.72);
      border: 1px solid rgba(255,255,255,.10);
      white-space: nowrap;
      box-shadow: 0 12px 28px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .label .k{ color: var(--accent); font-weight: 700; margin-right: 6px; }

    @media (max-width: 980px){
      body{ overflow:auto; }
      .app{ height:auto; min-height:100%; grid-template-columns: 1fr; }
      .main{ height: 62vh; }
    }
  </style>

  <!-- Import map: Three + Addons (OrbitControls ecc.) -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div class="app">
    <aside class="sidebar">
      <div class="brand">
        <h1>Presentazione 3D — Biologia</h1>
        <p>Apparato cardiocircolatorio & sistema nervoso. Modelli 3D semplificati ma didattici, con animazioni e controlli per proiezione.</p>
      </div>

      <div class="nav" id="nav">
        <button class="active" data-scene="heart">
          <div class="title">Cuore & Circolazione</div>
          <div class="desc">Battito, camere, valvole e flussi (rosso/blu).</div>
        </button>
        <button data-scene="neuron">
          <div class="title">Neurone</div>
          <div class="desc">Dendriti, assone, mielina e conduzione saltatoria.</div>
        </button>
        <button data-scene="synapse">
          <div class="title">Sinapsi</div>
          <div class="desc">Rilascio neurotrasmettitori step-by-step.</div>
        </button>
        <button data-scene="nervous">
          <div class="title">Sistema Nervoso</div>
          <div class="desc">SNC + SNP, somatico/autonomo, arco riflesso.</div>
        </button>
        <button data-scene="action">
          <div class="title">Impulsi Elettrici</div>
          <div class="desc">Potenziale d’azione + Na⁺/K⁺ + rete neurale.</div>
        </button>
      </div>

      <div class="controls">
        <div class="row">
          <button class="btn primary" id="btnPlay">Play</button>
          <button class="btn" id="btnPause">Pause</button>
          <button class="btn danger" id="btnReset">Reset</button>
        </div>
        <div class="row">
          <div class="slider">
            <label>
              <span>Velocità animazioni</span>
              <span id="speedVal">1.00×</span>
            </label>
            <input id="speed" type="range" min="0.25" max="2.5" step="0.05" value="1.00" />
          </div>
        </div>
        <div class="row">
          <button class="btn toggleOn" id="btnLabels">Labels: ON</button>
          <button class="btn" id="btnHelp">Guida</button>
        </div>
      </div>
    </aside>

    <main class="main" id="main">
      <canvas id="c"></canvas>

      <div class="hud">
        <div class="topbar">
          <div class="panel" id="panel">
            <h2 id="panelTitle">Cuore & Apparato cardiocircolatorio</h2>
            <p id="panelText">
              Ruota con il mouse/touch, zoom con rotellina/pinch. Osserva sistole/diastole, valvole e flussi: rosso = sangue ossigenato, blu = deossigenato.
            </p>
          </div>

          <div class="mini">
            <div class="kv">
              <b>Sezione</b><span id="kvScene">heart</span>
              <b>Animazione</b><span id="kvState">playing</span>
              <b>Tempo</b><span id="kvTime">0.00 s</span>
              <b>FPS</b><span id="kvFps">—</span>
            </div>
          </div>
        </div>

        <div class="bottombar">
          <div class="legend" id="legend">
            <div class="chips" id="chips"></div>
          </div>

          <div class="toast" id="toast">
            <div class="hint" id="toastText"></div>
          </div>
        </div>
      </div>

      <div class="labelLayer" id="labelLayer"></div>
    </main>
  </div>

  <!-- Tutto il JavaScript va in module, così possiamo importare OrbitControls -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    /***********************************************************************
     * UTIL & UI
     ***********************************************************************/
    const $ = (sel)=>document.querySelector(sel);
    const $$ = (sel)=>Array.from(document.querySelectorAll(sel));

    const state = {
      sceneKey: 'heart',
      playing: true,
      speed: 1.0,
      labels: true,
      t: 0,
      last: performance.now(),
      fps: 0,
      _fpsAcc: 0,
      _fpsCount: 0
    };

    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(a,b,x){
      const t = clamp((x-a)/(b-a), 0, 1);
      return t*t*(3-2*t);
    }

    function setToast(msg, ms=2300){
      const toast = $('#toast');
      $('#toastText').textContent = msg;
      toast.classList.add('show');
      clearTimeout(setToast._tm);
      setToast._tm = setTimeout(()=>toast.classList.remove('show'), ms);
    }

    function setLegend(chips){
      const el = $('#chips');
      el.innerHTML = '';
      for (const c of chips){
        const chip = document.createElement('div');
        chip.className = 'chip';
        const dot = document.createElement('div');
        dot.className = 'dot';
        dot.style.background = c.color;
        chip.appendChild(dot);
        const span = document.createElement('span');
        span.textContent = c.label;
        chip.appendChild(span);
        el.appendChild(chip);
      }
    }

    /***********************************************************************
     * THREE: RENDERER / CAMERA / CONTROLS / LIGHTS
     ***********************************************************************/
    const canvas = $('#c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1020, 0.028);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 200);
    camera.position.set(0, 1.8, 7.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 2.4;
    controls.maxDistance = 18;
    controls.target.set(0, 1.05, 0);

    const amb = new THREE.AmbientLight(0x8aa3ff, 0.22);
    scene.add(amb);

    const key = new THREE.DirectionalLight(0xffffff, 1.25);
    key.position.set(4, 6, 3);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x67d5ff, 0.55);
    fill.position.set(-6, 2, 4);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(0xa6ffcb, 0.35);
    rim.position.set(0, 5, -8);
    scene.add(rim);

    const grid = new THREE.GridHelper(24, 24, 0x24315c, 0x16204a);
    grid.position.y = -0.15;
    grid.material.transparent = true;
    grid.material.opacity = 0.18;
    scene.add(grid);

    const deco = new THREE.Group();
    scene.add(deco);
    (function addDeco(){
      const g = new THREE.SphereGeometry(0.06, 16, 16);
      for (let i=0;i<42;i++){
        const m = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.55 + Math.random()*0.15, 0.85, 0.62),
          emissive: 0x0b1020,
          roughness: 0.25,
          metalness: 0.25,
          transparent: true,
          opacity: 0.55
        });
        const s = new THREE.Mesh(g, m);
        s.position.set((Math.random()-0.5)*18, Math.random()*9, (Math.random()-0.5)*18);
        s.scale.setScalar(0.7 + Math.random()*1.7);
        deco.add(s);
      }
    })();

    function resize(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    /***********************************************************************
     * LABELS (overlay HTML ancorati a oggetti 3D)
     ***********************************************************************/
    const labelLayer = $('#labelLayer');
    const labelPool = new Map();
    const labelAnchors = []; // {key, object3D, text, color}

    function clearLabels(){
      labelAnchors.length = 0;
      labelLayer.innerHTML = '';
      labelPool.clear();
    }

    function addLabel(key, object3D, text, color='#67d5ff'){
      labelAnchors.push({ key, object3D, text, color });
      const div = document.createElement('div');
      div.className = 'label';
      div.innerHTML = `<span class="k">●</span>${text}`;
      div.querySelector('.k').style.color = color;
      labelLayer.appendChild(div);
      labelPool.set(key, div);
    }

    function updateLabels(){
      labelLayer.style.display = state.labels ? 'block' : 'none';
      if (!state.labels) return;

      const rect = canvas.getBoundingClientRect();
      for (const a of labelAnchors){
        const div = labelPool.get(a.key);
        if (!div) continue;
        const pos = new THREE.Vector3();
        a.object3D.getWorldPosition(pos);
        pos.project(camera);

        const visible = pos.z < 1;
        div.style.display = visible ? 'block' : 'none';
        if (!visible) continue;

        const x = (pos.x * 0.5 + 0.5) * rect.width;
        const y = (-pos.y * 0.5 + 0.5) * rect.height;
        div.style.left = `${x}px`;
        div.style.top  = `${y}px`;
      }
    }

    /***********************************************************************
     * HELPERS
     ***********************************************************************/
    function matSoft(color, emissive=0x050813){
      return new THREE.MeshStandardMaterial({
        color,
        emissive,
        roughness: 0.28,
        metalness: 0.18
      });
    }
    function matGlass(color, opacity=0.22){
      return new THREE.MeshPhysicalMaterial({
        color,
        roughness: 0.08,
        metalness: 0.0,
        transmission: 1.0,
        thickness: 0.25,
        transparent: true,
        opacity,
        ior: 1.35
      });
    }
    function makeArrow(color=0x67d5ff){
      const g1 = new THREE.CylinderGeometry(0.03, 0.03, 0.8, 18);
      const g2 = new THREE.ConeGeometry(0.09, 0.22, 20);
      const m = new THREE.MeshStandardMaterial({ color, emissive: 0x060b18, roughness: 0.35, metalness: 0.2 });
      const shaft = new THREE.Mesh(g1, m);
      const head = new THREE.Mesh(g2, m);
      head.position.y = 0.51;
      const group = new THREE.Group();
      group.add(shaft, head);
      return group;
    }

    class FlowParticles {
      constructor(curve, opts){
        this.curve = curve;
        this.count = opts.count ?? 120;
        this.speed = opts.speed ?? 0.15;
        this.size = opts.size ?? 0.04;
        this.color = opts.color ?? 0xff3b59;
        this.opacity = opts.opacity ?? 0.9;
        this.phase = opts.phase ?? 0;
        this.jitter = opts.jitter ?? 0.03;
        this.group = new THREE.Group();

        const geom = new THREE.SphereGeometry(this.size, 12, 12);
        const mat = new THREE.MeshStandardMaterial({
          color: this.color,
          emissive: new THREE.Color(this.color).multiplyScalar(0.25),
          roughness: 0.25,
          metalness: 0.2,
          transparent: true,
          opacity: this.opacity
        });

        this.meshes = [];
        for (let i=0;i<this.count;i++){
          const m = new THREE.Mesh(geom, mat);
          m.userData.u = (i/this.count + this.phase) % 1;
          this.group.add(m);
          this.meshes.push(m);
        }
      }
      reset(){
        for (let i=0;i<this.meshes.length;i++){
          this.meshes[i].userData.u = (i/this.meshes.length + this.phase) % 1;
        }
      }
      update(dt, speedMul=1){
        const v = dt * this.speed * speedMul;
        for (const m of this.meshes){
          m.userData.u = (m.userData.u + v) % 1;
          const u = m.userData.u;
          const p = this.curve.getPointAt(u);
          const t = this.curve.getTangentAt(u);
          m.position.copy(p);
          const n = new THREE.Vector3(-t.z, 0, t.x).normalize();
          m.position.addScaledVector(n, (Math.sin((u*12 + m.id)*2.1)*0.5 + (Math.random()-0.5))*this.jitter);
        }
      }
    }

    /***********************************************************************
     * SCENE MANAGER
     ***********************************************************************/
    const root = new THREE.Group();
    scene.add(root);

    const scenes = {};
    let active = null;

    function setScene(key){
      root.clear();
      clearLabels();

      state.sceneKey = key;
      $('#kvScene').textContent = key;

      controls.target.set(0, 1.05, 0);
      controls.update();

      active = scenes[key];
      if (!active) return;

      active.build(root);

      $('#panelTitle').textContent = active.title;
      $('#panelText').textContent = active.text;
      setLegend(active.legendChips || []);

      $$('#nav button').forEach(b => b.classList.toggle('active', b.dataset.scene === key));
      setToast(active.toast ?? 'Suggerimento: trascina per ruotare, rotellina/pinch per zoom.', 2600);
    }

    function reset(){
      state.t = 0;
      if (active && active.reset) active.reset();
      setToast('Animazione reimpostata.', 1600);
    }

    /***********************************************************************
     * SCENE 1: HEART
     ***********************************************************************/
    scenes.heart = (function(){
      let heartGroup, valves, flowBlue, flowRed, arrows;
      let beatPhase = 0;
      let curveBlue, curveRed;

      function build(parent){
        heartGroup = new THREE.Group();
        parent.add(heartGroup);

        const shellGeom = new THREE.SphereGeometry(1.55, 42, 36);
        shellGeom.scale(1.0, 1.2, 0.85);
        const shell = new THREE.Mesh(shellGeom, matGlass(0xff3b59, 0.12));
        shell.position.set(0, 1.15, 0);
        heartGroup.add(shell);

        const chambers = new THREE.Group();
        heartGroup.add(chambers);

        const atrioDx = new THREE.Mesh(new THREE.SphereGeometry(0.46, 32, 24), matSoft(0x4ea0ff, 0x060b18));
        const atrioSx = new THREE.Mesh(new THREE.SphereGeometry(0.46, 32, 24), matSoft(0xff3b59, 0x120613));
        const ventDx  = new THREE.Mesh(new THREE.SphereGeometry(0.62, 36, 26), matSoft(0x2e6bff, 0x050813));
        const ventSx  = new THREE.Mesh(new THREE.SphereGeometry(0.62, 36, 26), matSoft(0xd9153a, 0x150612));

        atrioDx.position.set(-0.35, 1.55, 0.28);
        atrioSx.position.set( 0.35, 1.55,-0.28);
        ventDx.position.set( -0.42, 0.92, 0.18);
        ventSx.position.set(  0.42, 0.92,-0.18);
        ventSx.scale.set(1.0, 1.1, 0.95);

        chambers.add(atrioDx, atrioSx, ventDx, ventSx);

        addLabel('ad', atrioDx, 'Atrio destro (deossigenato)', '#4ea0ff');
        addLabel('vd', ventDx,  'Ventricolo destro → arteria polmonare', '#2e6bff');
        addLabel('as', atrioSx, 'Atrio sinistro (ossigenato)', '#ff3b59');
        addLabel('vs', ventSx,  'Ventricolo sinistro → aorta', '#ff3b59');

        valves = new THREE.Group();
        heartGroup.add(valves);

        const gValve = new THREE.CircleGeometry(0.18, 32);
        const mValve = new THREE.MeshStandardMaterial({
          color: 0xe8eeff, emissive: 0x0b1020, roughness: 0.25, metalness: 0.25,
          side: THREE.DoubleSide, transparent: true, opacity: 0.85
        });

        const tricuspide = new THREE.Mesh(gValve, mValve);
        tricuspide.position.set(-0.40, 1.23, 0.22);
        tricuspide.rotation.x = Math.PI/2;

        const mitrale = new THREE.Mesh(gValve, mValve);
        mitrale.position.set(0.40, 1.23, -0.22);
        mitrale.rotation.x = Math.PI/2;

        const polmonare = new THREE.Mesh(gValve, mValve);
        polmonare.position.set(-0.55, 1.02, -0.48);
        polmonare.rotation.z = Math.PI/2;

        const aortica = new THREE.Mesh(gValve, mValve);
        aortica.position.set(0.55, 1.02, 0.48);
        aortica.rotation.z = Math.PI/2;

        valves.add(tricuspide, mitrale, polmonare, aortica);

        addLabel('v1', tricuspide, 'Valvola tricuspide', '#a6ffcb');
        addLabel('v2', mitrale, 'Valvola mitrale', '#a6ffcb');
        addLabel('v3', polmonare, 'Valvola polmonare', '#a6ffcb');
        addLabel('v4', aortica, 'Valvola aortica', '#a6ffcb');

        arrows = new THREE.Group();
        heartGroup.add(arrows);

        const arrPulm = makeArrow(0x2e6bff);
        arrPulm.position.set(-1.35, 1.62, -0.55);
        arrPulm.rotation.z = 0.35;
        arrPulm.rotation.x = -0.25;

        const arrSys = makeArrow(0xff3b59);
        arrSys.position.set(1.25, 1.80, 0.55);
        arrSys.rotation.z = -0.35;
        arrSys.rotation.x = -0.20;

        arrows.add(arrPulm, arrSys);

        curveBlue = new THREE.CatmullRomCurve3([
          new THREE.Vector3(-1.3, 2.2, 0.65),
          new THREE.Vector3(-0.95, 1.95, 0.48),
          new THREE.Vector3(-0.55, 1.75, 0.35),
          atrioDx.position.clone(),
          new THREE.Vector3(-0.40, 1.23, 0.22),
          ventDx.position.clone(),
          new THREE.Vector3(-0.55, 1.02, -0.48),
          new THREE.Vector3(-0.95, 1.25, -0.75),
          new THREE.Vector3(-1.55, 1.65, -0.65),
          new THREE.Vector3(-2.0, 1.95, -0.35)
        ]);

        curveRed = new THREE.CatmullRomCurve3([
          new THREE.Vector3(2.0, 1.95, 0.35),
          new THREE.Vector3(1.55, 1.65, 0.65),
          new THREE.Vector3(0.95, 1.35, 0.35),
          atrioSx.position.clone(),
          new THREE.Vector3(0.40, 1.23, -0.22),
          ventSx.position.clone(),
          new THREE.Vector3(0.55, 1.02, 0.48),
          new THREE.Vector3(0.95, 1.25, 0.85),
          new THREE.Vector3(1.55, 1.85, 0.55),
          new THREE.Vector3(1.8, 2.35, 0.05)
        ]);

        flowBlue = new FlowParticles(curveBlue, { count: 140, speed: 0.10, size: 0.040, color: 0x2e6bff, opacity: 0.95, jitter: 0.035, phase: 0.15 });
        flowRed  = new FlowParticles(curveRed,  { count: 140, speed: 0.10, size: 0.040, color: 0xff3b59, opacity: 0.95, jitter: 0.035, phase: 0.65 });
        heartGroup.add(flowBlue.group, flowRed.group);

        heartGroup.rotation.y = 0.65;

        // legenda è gestita da setScene
      }

      function update(dt){
        beatPhase += dt * 2.2 * state.speed;
        const beat = 0.5 + 0.5*Math.sin(beatPhase);
        const lub = Math.pow(Math.max(0, Math.sin(beatPhase)), 2.6);
        const dub = Math.pow(Math.max(0, Math.sin(beatPhase + 1.55)), 4.2);
        const pulse = clamp(0.15 + 0.85*(0.62*lub + 0.38*dub), 0, 1);

        const scale = 1.0 - 0.09*pulse;
        heartGroup.scale.set(scale, 1.0 - 0.06*pulse, scale);

        const systole = smoothstep(0.40, 0.78, beat);
        const diastole = 1.0 - systole;

        const [tric, mitr, pulm, aort] = valves.children;
        tric.rotation.z = lerp(0.0, 0.9, diastole);
        mitr.rotation.z = lerp(0.0, -0.9, diastole);
        pulm.rotation.y = lerp(0.0, 0.9, systole);
        aort.rotation.y = lerp(0.0, -0.9, systole);

        const flowMul = 0.65 + 1.05*systole;
        flowBlue.update(dt, flowMul);
        flowRed.update(dt, flowMul);

        arrows.children[0].scale.setScalar(1.0 + 0.08*Math.sin(beatPhase*1.3));
        arrows.children[1].scale.setScalar(1.0 + 0.08*Math.sin(beatPhase*1.3 + 1.1));
      }

      function reset(){
        beatPhase = 0;
        flowBlue.reset();
        flowRed.reset();
        heartGroup.scale.set(1,1,1);
        heartGroup.rotation.y = 0.65;
      }

      return {
        title: 'Cuore & Apparato cardiocircolatorio',
        text: 'Modello 3D didattico con 4 camere. Animazione di sistole/diastole, valvole sincronizzate e flussi: rosso = ossigenato, blu = deossigenato.',
        toast: 'Cuore: osserva le valvole (aprono/chiudono) e i flussi rosso/blu.',
        legendChips: [
          { label: 'Sangue ossigenato', color: '#ff3b59' },
          { label: 'Sangue deossigenato', color: '#2e6bff' },
          { label: 'Valvole', color: '#a6ffcb' }
        ],
        build, update, reset
      };
    })();

    /***********************************************************************
     * SCENE 2/3/4/5
     * Per brevità qui riuso ESATTAMENTE le scene già fornite prima:
     * (Neurone, Sinapsi, Sistema Nervoso, Impulsi Elettrici)
     * Sono identiche, solo migrate dentro <script type="module"> e con OrbitControls importato correttamente.
     *
     * Qui sotto includo le scene complete senza cambiare la logica.
     ***********************************************************************/

    // === NEURON ===
    scenes.neuron = (function(){
      let g, soma, axon, dendrites, myelin, nodes, impulse;
      let curve, flow;
      let phase = 0;

      function build(parent){
        g = new THREE.Group();
        parent.add(g);

        const somaGeom = new THREE.SphereGeometry(0.65, 44, 34);
        soma = new THREE.Mesh(somaGeom, matSoft(0xa6ffcb, 0x06120a));
        soma.position.set(-1.6, 1.2, 0);
        g.add(soma);

        const nuc = new THREE.Mesh(new THREE.SphereGeometry(0.22, 24, 18), matGlass(0x67d5ff, 0.20));
        nuc.position.set(-1.45, 1.25, 0.10);
        g.add(nuc);

        dendrites = new THREE.Group();
        g.add(dendrites);

        const dendMat = matSoft(0x7ef0d4, 0x04110c);
        function branch(from, dir, len, r0){
          const segs = 5;
          let p = from.clone();
          for (let i=0;i<segs;i++){
            const t = (i+1)/segs;
            const step = dir.clone().multiplyScalar(len/segs);
            const np = p.clone().add(step).add(new THREE.Vector3((Math.random()-0.5)*0.12, (Math.random()-0.5)*0.12, (Math.random()-0.5)*0.12));
            const v = new THREE.Vector3().subVectors(np, p);
            const cyl = new THREE.Mesh(
              new THREE.CylinderGeometry(r0*(1-t)*0.9, r0*(1-t), v.length(), 12),
              dendMat
            );
            cyl.position.copy(p.clone().add(np).multiplyScalar(0.5));
            cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), v.clone().normalize());
            dendrites.add(cyl);

            if (i>1){
              const sp = new THREE.Mesh(new THREE.SphereGeometry(0.06*(1-t), 10, 10), matSoft(0xa6ffcb, 0x04110c));
              sp.position.copy(np).add(new THREE.Vector3((Math.random()-0.5)*0.12, (Math.random()-0.5)*0.12, (Math.random()-0.5)*0.12));
              dendrites.add(sp);
            }
            p = np;
          }
          return p;
        }
        const base = soma.position.clone().add(new THREE.Vector3(-0.15, 0.25, 0));
        for (let i=0;i<8;i++){
          const dir = new THREE.Vector3(
            -0.8 + Math.random()*0.3,
            0.25 + (Math.random()-0.5)*0.9,
            (Math.random()-0.5)*1.2
          ).normalize();
          const end = branch(base, dir, 1.8 + Math.random()*0.9, 0.11);
          const dir2 = dir.clone().add(new THREE.Vector3((Math.random()-0.5)*0.7, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.7)).normalize();
          branch(end, dir2, 1.2 + Math.random()*0.8, 0.07);
        }

        curve = new THREE.CatmullRomCurve3([
          soma.position.clone().add(new THREE.Vector3(0.55, -0.10, 0.0)),
          new THREE.Vector3(-0.2, 0.9, 0.1),
          new THREE.Vector3(1.2, 1.0, -0.25),
          new THREE.Vector3(2.8, 1.2, 0.25),
          new THREE.Vector3(4.3, 1.05, 0.0)
        ]);

        axon = new THREE.Mesh(
          new THREE.TubeGeometry(curve, 160, 0.085, 16, false),
          matSoft(0x67d5ff, 0x061020)
        );
        g.add(axon);

        myelin = new THREE.Group();
        nodes = new THREE.Group();
        g.add(myelin, nodes);

        const ringMat = matSoft(0xe8eeff, 0x050813);
        const nodeMat = matSoft(0xff5c7a, 0x12060e);

        const segments = 12;
        for (let i=0;i<segments;i++){
          const u0 = i/(segments);
          const u1 = (i+1)/(segments);
          const uMid = (u0+u1)*0.5;

          const p = curve.getPointAt(uMid);
          const t = curve.getTangentAt(uMid).normalize();

          const ring = new THREE.Mesh(new THREE.CylinderGeometry(0.145, 0.145, 0.30, 22, 1, true), ringMat);
          ring.position.copy(p);
          ring.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), t);
          ring.rotateX(Math.PI/2);
          myelin.add(ring);

          const node = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.020, 10, 22), nodeMat);
          const pn = curve.getPointAt(u1);
          const tn = curve.getTangentAt(u1).normalize();
          node.position.copy(pn);
          node.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), tn);
          node.rotateX(Math.PI/2);
          nodes.add(node);
        }

        const term = new THREE.Group();
        g.add(term);
        const endP = curve.getPointAt(1.0);
        for (let i=0;i<7;i++){
          const b = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 14), matSoft(0xa6ffcb, 0x06120a));
          b.position.copy(endP).add(new THREE.Vector3(0.12 + Math.random()*0.35, (Math.random()-0.5)*0.55, (Math.random()-0.5)*0.55));
          term.add(b);
        }

        flow = new FlowParticles(curve, { count: 90, speed: 0.16, size: 0.032, color: 0xffd166, opacity: 0.95, jitter: 0.01, phase: 0.0 });
        g.add(flow.group);

        impulse = new THREE.Mesh(new THREE.SphereGeometry(0.10, 18, 16), new THREE.MeshStandardMaterial({
          color: 0xffd166, emissive: 0xffa200, roughness: 0.15, metalness: 0.15
        }));
        g.add(impulse);

        addLabel('soma', soma, 'Corpo cellulare (soma)', '#a6ffcb');
        addLabel('dend', dendrites, 'Dendriti (ricezione segnali)', '#7ef0d4');
        addLabel('axon', axon, 'Assone (conduzione)', '#67d5ff');
        addLabel('my', myelin, 'Guaina mielinica', '#e8eeff');
        addLabel('node', nodes, 'Nodi di Ranvier', '#ff5c7a');

        g.rotation.y = -0.25;
        controls.target.set(1.1, 1.1, 0);
        camera.position.set(0.2, 1.9, 8.2);
      }

      function update(dt){
        phase += dt * 0.9 * state.speed;

        soma.scale.setScalar(1.0 + 0.02*Math.sin(phase*2.0));
        dendrites.rotation.z = 0.02*Math.sin(phase*1.3);
        myelin.rotation.z = 0.01*Math.sin(phase*1.3 + 1.2);

        const u = (phase*0.22) % 1;
        impulse.position.copy(curve.getPointAt(u));

        const nodesCount = nodes.children.length;
        let boost = 1.0;
        for (let i=0;i<nodesCount;i++){
          const un = (i+1)/12;
          const d = Math.min(Math.abs(u-un), 1-Math.abs(u-un));
          boost += Math.exp(-(d*d)/0.0008) * 1.8;
        }
        flow.update(dt, (0.6 + 0.6*boost));

        for (let i=0;i<nodes.children.length;i++){
          const un = (i+1)/12;
          const d = Math.min(Math.abs(u-un), 1-Math.abs(u-un));
          const s = 1.0 + Math.exp(-(d*d)/0.0007) * 0.9;
          nodes.children[i].scale.setScalar(s);
        }
      }

      function reset(){
        phase = 0;
        flow.reset();
      }

      return {
        title: 'Neurone (struttura + conduzione saltatoria)',
        text: 'Il neurone è composto da soma, dendriti e assone. La guaina mielinica isola l’assone e lascia scoperti i nodi di Ranvier: l’impulso “salta” nodo‑nodo (conduzione saltatoria).',
        toast: 'Neurone: usa Labels per riconoscere le parti principali.',
        legendChips: [
          { label: 'Impulso (segnale)', color: '#ffd166' },
          { label: 'Assone', color: '#67d5ff' },
          { label: 'Mielina', color: '#e8eeff' },
          { label: 'Nodi di Ranvier', color: '#ff5c7a' },
        ],
        build, update, reset
      };
    })();

    // === SYNAPSE ===
    scenes.synapse = (function(){
      let g, pre, post, cleftPlane, vesicles, receptors, nts;
      let phase = 0;
      let step = 0;
      let stepT = 0;

      function build(parent){
        g = new THREE.Group();
        parent.add(g);

        const preMat = matSoft(0x67d5ff, 0x061020);
        const postMat = matSoft(0xa6ffcb, 0x06120a);

        pre = new THREE.Mesh(new THREE.CapsuleGeometry(1.35, 0.8, 16, 28), preMat);
        pre.position.set(-1.35, 1.2, 0);
        pre.rotation.z = Math.PI/2;
        g.add(pre);

        post = new THREE.Mesh(new THREE.CapsuleGeometry(1.55, 0.9, 16, 28), postMat);
        post.position.set(1.45, 1.2, 0);
        post.rotation.z = Math.PI/2;
        g.add(post);

        cleftPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(0.55, 2.4),
          new THREE.MeshStandardMaterial({ color: 0xe8eeff, transparent: true, opacity: 0.08, side: THREE.DoubleSide })
        );
        cleftPlane.position.set(0.05, 1.2, 0);
        cleftPlane.rotation.y = Math.PI/2;
        g.add(cleftPlane);

        vesicles = new THREE.Group();
        g.add(vesicles);

        const vesMat = matGlass(0xffd166, 0.22);
        for (let i=0;i<14;i++){
          const v = new THREE.Mesh(new THREE.SphereGeometry(0.16, 18, 14), vesMat);
          v.position.set(
            -1.35 + (Math.random()*0.8-0.4),
            1.2 + (Math.random()*1.0-0.5),
            (Math.random()*0.9-0.45)
          );
          v.userData.home = v.position.clone();
          vesicles.add(v);
        }

        receptors = new THREE.Group();
        g.add(receptors);

        const recMat = matSoft(0xff5c7a, 0x14060e);
        for (let i=0;i<10;i++){
          const r = new THREE.Mesh(new THREE.TorusGeometry(0.13, 0.04, 10, 18), recMat);
          r.position.set(
            0.92 + Math.random()*0.35,
            1.2 + (Math.random()*1.6-0.8),
            (Math.random()*0.9-0.45)
          );
          r.rotation.y = Math.PI/2;
          receptors.add(r);
        }

        nts = [];
        const ntGeom = new THREE.SphereGeometry(0.05, 12, 10);
        const ntMat = new THREE.MeshStandardMaterial({
          color: 0xffd166,
          emissive: 0xffa200,
          roughness: 0.25,
          metalness: 0.1,
          transparent: true,
          opacity: 0.95
        });
        for (let i=0;i<140;i++){
          const nt = new THREE.Mesh(ntGeom, ntMat);
          nt.visible = false;
          nt.position.set(-0.8, 1.2, 0);
          nt.userData.v = new THREE.Vector3();
          nt.userData.life = 0;
          nts.push(nt);
          g.add(nt);
        }

        addLabel('pre', pre, 'Terminale presinaptico', '#67d5ff');
        addLabel('ves', vesicles, 'Vescicole (neurotrasmettitori)', '#ffd166');
        addLabel('cleft', cleftPlane, 'Fessura sinaptica', '#e8eeff');
        addLabel('rec', receptors, 'Recettori postsinaptici', '#ff5c7a');
        addLabel('post', post, 'Neurone post‑sinaptico', '#a6ffcb');

        g.rotation.y = 0.35;
        controls.target.set(0.15, 1.2, 0);
        camera.position.set(0.2, 1.9, 8.0);

        setStep(0);
      }

      function setStep(s){
        step = s;
        stepT = 0;
        const messages = [
          'Step 1/4: Arrivo del segnale al terminale presinaptico.',
          'Step 2/4: Vescicole → fusione con membrana (esocitosi).',
          'Step 3/4: Neurotrasmettitori attraversano la fessura.',
          'Step 4/4: Legame ai recettori → risposta postsinaptica.'
        ];
        setToast(messages[step], 2400);
      }

      function emitNT(burst=32){
        let n = burst;
        for (const nt of nts){
          if (n<=0) break;
          if (nt.visible) continue;
          nt.visible = true;
          nt.position.set(-0.55, 1.2 + (Math.random()-0.5)*0.35, (Math.random()-0.5)*0.25);
          nt.userData.v.set(
            1.2 + Math.random()*0.9,
            (Math.random()-0.5)*0.7,
            (Math.random()-0.5)*0.6
          );
          nt.userData.life = 1.0;
          n--;
        }
      }

      function update(dt){
        phase += dt * state.speed;
        stepT += dt * (0.35 + 0.35*state.speed);

        if (stepT > 1.0){
          setStep((step + 1) % 4);
        }

        pre.scale.set(1, 1, 1 + 0.02*Math.sin(phase*2.1));
        post.scale.set(1, 1, 1 + 0.02*Math.sin(phase*2.1 + 1.0));

        if (step === 0){
          for (const v of vesicles.children){
            v.position.copy(v.userData.home).add(new THREE.Vector3(
              (Math.sin(phase*3 + v.id)*0.03),
              (Math.cos(phase*2 + v.id)*0.03),
              (Math.sin(phase*2.4 + v.id)*0.03)
            ));
          }
        } else if (step === 1){
          const k = smoothstep(0.05, 0.95, stepT);
          let i=0;
          for (const v of vesicles.children){
            const target = new THREE.Vector3(-0.75, 1.2 + (i-6)*0.08, (i%3-1)*0.12);
            v.position.copy(v.userData.home).lerp(target, k);
            v.scale.setScalar(1.0 - 0.35*k);
            i++;
          }
          if (stepT > 0.45 && stepT < 0.55) emitNT(44);
        } else if (step === 2){
          if (Math.random() < 0.18*state.speed) emitNT(8);
        } else if (step === 3){
          const glow = 0.6 + 0.4*Math.sin(phase*4.0);
          for (const r of receptors.children){
            r.scale.setScalar(1.0 + 0.25*glow);
          }
        }

        for (const nt of nts){
          if (!nt.visible) continue;
          nt.position.addScaledVector(nt.userData.v, dt * 0.65 * state.speed);
          nt.userData.v.multiplyScalar(0.985);
          nt.userData.v.x = lerp(nt.userData.v.x, 0.55, 0.02);

          if (nt.position.x > 0.95){
            let best = null, bestD = 1e9;
            for (const r of receptors.children){
              const d = r.position.distanceTo(nt.position);
              if (d < bestD){ bestD = d; best = r; }
            }
            if (best && bestD < 0.35){
              best.scale.setScalar(1.65);
            }
            nt.visible = false;
          }

          nt.userData.life -= dt * 0.25 * state.speed;
          if (nt.userData.life <= 0){
            nt.visible = false;
          }
        }
      }

      function reset(){
        phase = 0;
        setStep(0);
        for (const v of vesicles.children){
          v.position.copy(v.userData.home);
          v.scale.setScalar(1);
        }
        for (const nt of nts) nt.visible = false;
        for (const r of receptors.children) r.scale.setScalar(1);
      }

      return {
        title: 'Sinapsi chimica (step-by-step)',
        text: 'Arrivo del segnale → esocitosi delle vescicole → diffusione dei neurotrasmettitori → legame ai recettori e risposta postsinaptica.',
        toast: 'Sinapsi: la sequenza si ripete automaticamente. Usa Reset per tornare allo Step 1.',
        legendChips: [
          { label: 'Vescicole', color: '#ffd166' },
          { label: 'Neurotrasmettitori', color: '#ffb703' },
          { label: 'Recettori', color: '#ff5c7a' },
          { label: 'Post‑sinaptico', color: '#a6ffcb' },
        ],
        build, update, reset
      };
    })();

    // === NERVOUS ===
    scenes.nervous = (function(){
      let g, brain, spinal, somatic, autonomic, pulses, reflex;
      let phase = 0;

      function build(parent){
        g = new THREE.Group();
        parent.add(g);

        brain = new THREE.Mesh(new THREE.SphereGeometry(0.85, 44, 34), matSoft(0xff5c7a, 0x14060e));
        brain.position.set(0, 2.15, 0);
        brain.scale.set(1.15, 0.95, 1.0);
        g.add(brain);

        const gyri = new THREE.Group();
        const gyMat = new THREE.MeshStandardMaterial({ color: 0xff88a0, roughness: 0.55, metalness: 0.05, transparent: true, opacity: 0.65 });
        for (let i=0;i<6;i++){
          const t = new THREE.Mesh(new THREE.TorusGeometry(0.55 + i*0.05, 0.03, 10, 64), gyMat);
          t.position.copy(brain.position);
          t.rotation.x = (i*0.45);
          t.rotation.y = i*0.65;
          gyri.add(t);
        }
        g.add(gyri);

        spinal = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.16, 2.9, 18, 1, true), matSoft(0xe8eeff, 0x050813));
        spinal.position.set(0, 0.75, 0);
        g.add(spinal);

        const nerves = new THREE.Group();
        somatic = new THREE.Group();
        autonomic = new THREE.Group();
        nerves.add(somatic, autonomic);
        g.add(nerves);

        const somMat = matSoft(0x67d5ff, 0x061020);
        const autMat = matSoft(0xa6ffcb, 0x06120a);

        function addNerve(mat, points, radius){
          const curve = new THREE.CatmullRomCurve3(points);
          const mesh = new THREE.Mesh(new THREE.TubeGeometry(curve, 100, radius, 12, false), mat);
          return { curve, mesh };
        }

        const somCurves = [];
        const autCurves = [];
        const base = new THREE.Vector3(0, 1.1, 0);

        const targetsSom = [
          new THREE.Vector3(-2.6, 1.4, 0.6),
          new THREE.Vector3( 2.6, 1.4,-0.6),
          new THREE.Vector3(-2.2, 0.3, 0.9),
          new THREE.Vector3( 2.2, 0.3,-0.9),
          new THREE.Vector3(-1.6,-0.8, 0.4),
          new THREE.Vector3( 1.6,-0.8,-0.4),
        ];
        for (const t of targetsSom){
          const mid = base.clone().add(t).multiplyScalar(0.5).add(new THREE.Vector3(0.0, 0.35, 0));
          const { curve, mesh } = addNerve(somMat, [base, mid, t], 0.055);
          somatic.add(mesh);
          somCurves.push(curve);
        }

        const targetsAut = [
          new THREE.Vector3(-1.2, 1.0,-1.2),
          new THREE.Vector3( 1.2, 1.0, 1.2),
          new THREE.Vector3(-1.0, 0.2,-1.0),
          new THREE.Vector3( 1.0, 0.2, 1.0)
        ];
        for (const t of targetsAut){
          const mid = base.clone().add(t).multiplyScalar(0.5).add(new THREE.Vector3(0.0, 0.15, 0));
          const { curve, mesh } = addNerve(autMat, [base, mid, t], 0.045);
          autonomic.add(mesh);
          autCurves.push(curve);
        }

        pulses = [];
        function addPulse(curve, color, phase, speed){
          const fp = new FlowParticles(curve, { count: 70, speed, size: 0.030, color, opacity: 0.95, jitter: 0.008, phase });
          g.add(fp.group);
          pulses.push(fp);
        }
        for (let i=0;i<somCurves.length;i++) addPulse(somCurves[i], 0x67d5ff, i*0.12, 0.12);
        for (let i=0;i<autCurves.length;i++) addPulse(autCurves[i], 0xa6ffcb, 0.45 + i*0.14, 0.10);

        const reflexCurve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(-2.2, -0.8, 0.4),
          new THREE.Vector3(-1.1, 0.2, 0.2),
          new THREE.Vector3(0.0, 0.6, 0.0),
          new THREE.Vector3(1.1, 0.2,-0.2),
          new THREE.Vector3(2.1, -0.6,-0.4)
        ]);
        reflex = {
          fp: new FlowParticles(reflexCurve, { count: 60, speed: 0.18, size: 0.034, color: 0xffd166, opacity: 0.95, jitter: 0.01, phase: 0.05 }),
          line: new THREE.Mesh(new THREE.TubeGeometry(reflexCurve, 120, 0.032, 10, false), matGlass(0xffd166, 0.16))
        };
        g.add(reflex.fp.group, reflex.line);

        addLabel('brain', brain, 'SNC: Cervello', '#ff5c7a');
        addLabel('spinal', spinal, 'SNC: Midollo spinale', '#e8eeff');
        addLabel('som', somatic, 'SNP Somatico', '#67d5ff');
        addLabel('aut', autonomic, 'SNP Autonomo', '#a6ffcb');
        addLabel('ref', reflex.line, 'Arco riflesso (rapido)', '#ffd166');

        g.rotation.y = 0.25;
        controls.target.set(0, 1.1, 0);
        camera.position.set(0.2, 2.2, 9.0);
      }

      function update(dt){
        phase += dt * state.speed;
        brain.scale.set(1.15*(1+0.012*Math.sin(phase*2.0)), 0.95*(1+0.010*Math.sin(phase*2.0+1)), 1.0);
        for (const fp of pulses) fp.update(dt, 0.85);
        reflex.fp.update(dt, 1.0);
      }

      function reset(){
        phase = 0;
        for (const fp of pulses) fp.reset();
        reflex.fp.reset();
      }

      return {
        title: 'Sistema Nervoso (SNC + SNP) e arco riflesso',
        text: 'Schema 3D: cervello e midollo (SNC), nervi periferici (SNP). Distinzione: SNP somatico (blu) e autonomo (verde). Arco riflesso (giallo) mediato dal midollo.',
        toast: 'Sistema nervoso: segui i colori (somatico/autonomo) e il percorso giallo dell’arco riflesso.',
        legendChips: [
          { label: 'SNC (cervello)', color: '#ff5c7a' },
          { label: 'SNC (midollo)', color: '#e8eeff' },
          { label: 'SNP Somatico', color: '#67d5ff' },
          { label: 'SNP Autonomo', color: '#a6ffcb' },
          { label: 'Arco riflesso', color: '#ffd166' },
        ],
        build, update, reset
      };
    })();

    // === ACTION POTENTIAL ===
    scenes.action = (function(){
      let g, membrane, naIons, kIons, graphSprite, net, netNodes, netLines, wave;
      let phase = 0;

      const graph = {
        w: 820, h: 240,
        canvas: document.createElement('canvas'),
        ctx: null,
        tex: null
      };

      function actionPotential(t){
        const x = t;
        let v = -70;
        if (x < 0.18){
          v = -70;
        } else if (x < 0.32){
          v = lerp(-70, 35, smoothstep(0.18, 0.32, x));
        } else if (x < 0.46){
          v = lerp(35, -55, smoothstep(0.32, 0.46, x));
        } else if (x < 0.66){
          v = lerp(-55, -82, smoothstep(0.46, 0.66, x));
        } else {
          v = lerp(-82, -70, smoothstep(0.66, 0.98, x));
        }
        return v;
      }

      function buildGraph(){
        graph.canvas.width = graph.w;
        graph.canvas.height = graph.h;
        graph.ctx = graph.canvas.getContext('2d');
        graph.tex = new THREE.CanvasTexture(graph.canvas);
        graph.tex.colorSpace = THREE.SRGBColorSpace;

        const mat = new THREE.SpriteMaterial({ map: graph.tex, transparent: true, opacity: 0.98 });
        graphSprite = new THREE.Sprite(mat);
        graphSprite.scale.set(6.6, 1.95, 1);
        graphSprite.position.set(0, 2.55, -1.0);
        g.add(graphSprite);
      }

      function drawGraph(t){
        const ctx = graph.ctx;
        const W = graph.w, H = graph.h;
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle = 'rgba(15,24,51,0.78)';
        ctx.fillRect(0,0,W,H);

        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        for (let x=0;x<=W;x+=60){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
        for (let y=0;y<=H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

        ctx.fillStyle = 'rgba(232,238,255,0.92)';
        ctx.font = '600 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('Potenziale d’azione (mV)', 18, 28);

        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.fillStyle = 'rgba(169,182,230,0.95)';
        ctx.fillText('Riposo -70mV → Depolarizzazione → Picco → Ripolarizzazione → Iperpolarizzazione', 18, H-12);

        const vMin = -90, vMax = 40;
        function yOf(v){
          const a = (v - vMin)/(vMax - vMin);
          return H - (18 + a*(H-48));
        }

        ctx.strokeStyle = 'rgba(103,213,255,0.25)';
        ctx.beginPath(); ctx.moveTo(0, yOf(-70)); ctx.lineTo(W, yOf(-70)); ctx.stroke();

        ctx.strokeStyle = 'rgba(255,209,102,0.95)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let i=0;i<=600;i++){
          const x = i/600;
          const v = actionPotential(x);
          const px = 18 + x*(W-36);
          const py = yOf(v);
          if (i===0) ctx.moveTo(px,py);
          else ctx.lineTo(px,py);
        }
        ctx.stroke();

        const vNow = actionPotential(t);
        const px = 18 + t*(W-36);
        const py = yOf(vNow);

        ctx.fillStyle = 'rgba(255,209,102,0.25)';
        ctx.beginPath(); ctx.arc(px, py, 18, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = 'rgba(255,209,102,1)';
        ctx.beginPath(); ctx.arc(px, py, 6.5, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = 'rgba(232,238,255,0.95)';
        ctx.font = '700 14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.fillText(`${vNow.toFixed(0)} mV`, px + 14, py - 10);

        graph.tex.needsUpdate = true;
      }

      function build(parent){
        g = new THREE.Group();
        parent.add(g);

        membrane = new THREE.Mesh(new THREE.BoxGeometry(5.6, 0.25, 2.2), matSoft(0xe8eeff, 0x050813));
        membrane.position.set(0, 1.0, 0);
        membrane.material.transparent = true;
        membrane.material.opacity = 0.35;
        g.add(membrane);

        const chMatNa = matSoft(0x4ea0ff, 0x061020);
        const chMatK  = matSoft(0xff5c7a, 0x14060e);
        for (let i=0;i<10;i++){
          const ch = new THREE.Mesh(new THREE.CylinderGeometry(0.10, 0.10, 0.42, 16), (i%2===0)?chMatNa:chMatK);
          ch.position.set(-2.2 + i*0.48, 1.0, (i%2===0)?-0.55:0.55);
          ch.rotation.z = Math.PI/2;
          g.add(ch);
        }

        naIons = [];
        kIons = [];
        const naMat = new THREE.MeshStandardMaterial({ color: 0x4ea0ff, emissive: 0x0b1020, roughness: 0.25, metalness: 0.25 });
        const kMat  = new THREE.MeshStandardMaterial({ color: 0xff5c7a, emissive: 0x0b1020, roughness: 0.25, metalness: 0.25 });
        const ionG = new THREE.SphereGeometry(0.075, 14, 12);

        function spawnIon(arr, mat, side){
          const m = new THREE.Mesh(ionG, mat);
          m.userData.side = side;
          m.userData.x0 = -2.6 + Math.random()*5.2;
          m.userData.z0 = (Math.random()-0.5)*1.6;
          m.position.set(m.userData.x0, 1.0 + side*(0.65 + Math.random()*0.45), m.userData.z0);
          arr.push(m); g.add(m);
        }
        for (let i=0;i<80;i++) spawnIon(naIons, naMat, +1);
        for (let i=0;i<80;i++) spawnIon(kIons,  kMat,  -1);

        net = new THREE.Group();
        g.add(net);
        net.position.set(0, 0.05, -2.9);

        netNodes = [];
        const nodeMat = new THREE.MeshStandardMaterial({ color: 0xa6ffcb, emissive: 0x06120a, roughness: 0.35, metalness: 0.1 });
        for (let i=0;i<18;i++){
          const n = new THREE.Mesh(new THREE.SphereGeometry(0.11, 16, 14), nodeMat);
          n.position.set((Math.random()-0.5)*5.2, 0.55 + Math.random()*1.0, (Math.random()-0.5)*1.8);
          netNodes.push(n);
          net.add(n);
        }

        netLines = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x67d5ff, transparent:true, opacity: 0.22 }));
        net.add(netLines);

        wave = new THREE.Mesh(new THREE.SphereGeometry(0.16, 18, 16), new THREE.MeshStandardMaterial({
          color: 0xffd166, emissive: 0xffa200, roughness: 0.15, metalness: 0.1
        }));
        net.add(wave);

        buildGraph();

        addLabel('mem', membrane, 'Membrana + canali ionici', '#e8eeff');
        addLabel('na', g, 'Na⁺ (blu) / K⁺ (rosa)', '#67d5ff');
        addLabel('net', net, 'Rete neurale (effetto domino)', '#a6ffcb');
        addLabel('graph', graphSprite, 'Grafico potenziale d’azione', '#ffd166');

        g.rotation.y = -0.25;
        controls.target.set(0, 1.25, 0);
        camera.position.set(0.6, 2.25, 9.3);
      }

      function update(dt){
        phase += dt * state.speed;
        const t = (phase*0.16) % 1;
        drawGraph(t);

        const naOpen = smoothstep(0.18, 0.28, t) * (1.0 - smoothstep(0.30, 0.40, t));
        const kOpen  = smoothstep(0.34, 0.46, t) * (1.0 - smoothstep(0.70, 0.86, t));

        function stepIons(arr, open){
          for (const ion of arr){
            const targetY = 1.0 + (ion.userData.side > 0 ? 0.85 : -0.85);
            const restY   = 1.0 + ion.userData.side*(0.65 + (ion.id%7)*0.04);
            ion.position.x += Math.sin(phase*0.6 + ion.id)*dt*0.02;
            ion.position.z += Math.cos(phase*0.5 + ion.id)*dt*0.02;
            const toward = 0.8*open;
            const yGoal = lerp(restY, targetY, toward);
            ion.position.y = lerp(ion.position.y, yGoal, 0.06);

            if (open > 0.4 && Math.abs(ion.position.y - 1.0) < 0.08){
              ion.userData.side *= -1;
              ion.position.y = 1.0 + ion.userData.side*0.25;
            }
          }
        }

        stepIons(naIons, naOpen);
        stepIons(kIons,  kOpen);

        const ordered = netNodes.slice().sort((a,b)=>a.position.x-b.position.x);
        const u = (phase*0.22) % 1;
        const idxF = u * (ordered.length-1);
        const i0 = Math.floor(idxF);
        const i1 = Math.min(ordered.length-1, i0+1);
        const localT = idxF - i0;

        wave.position.copy(ordered[i0].position).lerp(ordered[i1].position, localT);

        for (const n of netNodes){
          const d = n.position.distanceTo(wave.position);
          const ex = Math.exp(-(d*d)/0.08);
          n.scale.setScalar(1.0 + 1.1*ex);
        }

        const edges = [];
        for (let i=0;i<netNodes.length;i++){
          for (let j=i+1;j<netNodes.length;j++){
            if (netNodes[i].position.distanceTo(netNodes[j].position) < 1.55) edges.push([i,j]);
          }
        }

        const needed = edges.length*2*3;
        const pos = new Float32Array(needed);
        let k=0;
        for (const [i,j] of edges){
          const A = netNodes[i].position;
          const B = netNodes[j].position;
          pos[k++]=A.x; pos[k++]=A.y; pos[k++]=A.z;
          pos[k++]=B.x; pos[k++]=B.y; pos[k++]=B.z;
        }
        netLines.geometry.dispose();
        netLines.geometry = new THREE.BufferGeometry();
        netLines.geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));

        netLines.material.opacity = clamp(0.14 + 0.18*(naOpen + kOpen) + 0.12, 0.10, 0.55);
        membrane.material.opacity = 0.28 + 0.12*(naOpen + kOpen);
      }

      function reset(){ phase = 0; }

      return {
        title: 'Impulsi elettrici: potenziale d’azione, Na⁺/K⁺ e rete neurale',
        text: 'Grafico sincronizzato con canali: Na⁺ entra (depolarizzazione), K⁺ contribuisce alla ripolarizzazione. Sotto: propagazione del segnale in una rete neurale (effetto domino).',
        toast: 'Impulsi: guarda il cursore sul grafico e come cambiano i flussi di Na⁺/K⁺.',
        legendChips: [
          { label: 'Na⁺', color: '#4ea0ff' },
          { label: 'K⁺', color: '#ff5c7a' },
          { label: 'Potenziale d’azione', color: '#ffd166' },
          { label: 'Rete neurale', color: '#a6ffcb' },
        ],
        build, update, reset
      };
    })();

    /***********************************************************************
     * UI WIRING
     ***********************************************************************/
    $('#btnPlay').addEventListener('click', ()=>{
      state.playing = true;
      $('#kvState').textContent = 'playing';
      setToast('Play', 900);
    });

    $('#btnPause').addEventListener('click', ()=>{
      state.playing = false;
      $('#kvState').textContent = 'paused';
      setToast('Pause', 900);
    });

    $('#btnReset').addEventListener('click', reset);

    $('#speed').addEventListener('input', (e)=>{
      state.speed = parseFloat(e.target.value);
      $('#speedVal').textContent = state.speed.toFixed(2) + '×';
    });

    $('#btnLabels').addEventListener('click', ()=>{
      state.labels = !state.labels;
      $('#btnLabels').classList.toggle('toggleOn', state.labels);
      $('#btnLabels').textContent = 'Labels: ' + (state.labels ? 'ON' : 'OFF');
      setToast(state.labels ? 'Labels attivate.' : 'Labels disattivate.', 1200);
    });

    $('#btnHelp').addEventListener('click', ()=>{
      setToast(
        'Controlli: trascina per ruotare • rotellina/pinch per zoom • Play/Pause/Reset • Slider velocità • Labels ON/OFF. Consiglio: F11 per schermo intero.',
        5200
      );
    });

    $$('#nav button').forEach(btn=>{
      btn.addEventListener('click', ()=> setScene(btn.dataset.scene));
    });

    /***********************************************************************
     * LOOP
     ***********************************************************************/
    function tick(now){
      const dt = Math.min(0.05, (now - state.last) / 1000);
      state.last = now;

      state._fpsAcc += dt;
      state._fpsCount++;
      if (state._fpsAcc >= 0.5){
        state.fps = Math.round(state._fpsCount / state._fpsAcc);
        state._fpsAcc = 0;
        state._fpsCount = 0;
        $('#kvFps').textContent = String(state.fps);
      }

      if (state.playing){
        state.t += dt * state.speed;
        if (active && active.update) active.update(dt);
      }

      $('#kvTime').textContent = state.t.toFixed(2) + ' s';

      controls.update();
      updateLabels();
      renderer.render(scene, camera);

      requestAnimationFrame(tick);
    }

    /***********************************************************************
     * START
     ***********************************************************************/
    function start(){
      setScene('heart');
      $('#speedVal').textContent = state.speed.toFixed(2) + '×';
      $('#kvState').textContent = state.playing ? 'playing' : 'paused';
      requestAnimationFrame(tick);
      setTimeout(()=>setToast('Suggerimento: premi F11 per schermo intero durante la presentazione.', 4200), 900);
    }

    // Se la pagina è aperta come file://, alcuni browser limitano importmap/CDN.
    // In quel caso usa la modalità offline (file locali) oppure apri con un server locale.
    start();
  </script>
</body>
</html>
