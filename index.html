<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Apparato cardiocircolatorio & Sistema nervoso — Presentazione 3D (offline-ready)</title>

  <!--
    OFFLINE (consigliato per l'uso in aula senza internet):
    Opzione A (semplice, richiede internet): lascia importmap su CDN (Three.js + Addons).
    Opzione B (offline completo): scarica e metti nella stessa cartella del file HTML:
      - three.module.js
      - OrbitControls.js (versione "jsm")
      - GLTFLoader.js (versione "jsm")
    Poi cambia importmap qui sotto così:
      "three": "./three.module.js",
      "three/addons/": "./addons/"
    e metti i loader in ./addons/controls/OrbitControls.js e ./addons/loaders/GLTFLoader.js

    Modelli 3D (GLB) richiesti e presenti nel repository "biology" alla radice:
      - jantung_manusia.glb           (cuore umano)
      - neuron.glb                    (neurone)
      - human_brain.glb               (cervello)
      - brain_project.glb             (variante cervello, opzionale)
  -->

  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1833cc;
      --text:#e8eeff;
      --muted:#a9b6e6;
      --accent:#67d5ff;
      --accent2:#a6ffcb;
      --danger:#ff5c7a;
      --shadow: 0 12px 30px rgba(0,0,0,.45);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 900px at 20% 10%, #192b66 0%, var(--bg) 55%, #060a14 100%); color: var(--text); font-family: var(--font); overflow: hidden; }

    .app{
      height:100%;
      display:grid;
      grid-template-columns: 310px 1fr;
      gap: 14px;
      padding: 14px;
    }

    .sidebar{
      background: linear-gradient(180deg, rgba(15,24,51,.82), rgba(10,16,34,.86));
      border: 1px solid rgba(103,213,255,.16);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction: column;
      overflow:hidden;
      min-width: 260px;
    }

    .brand{
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    .brand h1{ font-size: 15px; margin: 0 0 6px 0; letter-spacing: .3px; font-weight: 750; }
    .brand p{ margin: 0; font-size: 12.5px; color: var(--muted); line-height: 1.35; }

    .nav{ padding: 10px; display: grid; gap: 8px; overflow:auto; }
    .nav button{
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      text-align:left;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      outline: none;
    }
    .nav button:hover{ transform: translateY(-1px); border-color: rgba(103,213,255,.28); background: rgba(103,213,255,.08); }
    .nav button.active{ border-color: rgba(103,213,255,.50); background: rgba(103,213,255,.14); box-shadow: 0 0 0 1px rgba(103,213,255,.08) inset; }
    .nav .title{ font-weight: 700; font-size: 13.5px; margin-bottom: 2px; }
    .nav .desc{ font-size: 12px; color: var(--muted); line-height: 1.35; }

    .controls{
      margin-top: auto;
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.18));
    }
    .row{ display:flex; gap: 8px; align-items:center; flex-wrap: wrap; margin-bottom: 10px; }
    .row:last-child{ margin-bottom: 0; }

    .btn{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 9px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: background .12s ease, transform .12s ease, border-color .12s ease;
      font-size: 12.5px;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.09); border-color: rgba(103,213,255,.25); }
    .btn.primary{ border-color: rgba(103,213,255,.40); background: rgba(103,213,255,.16); }
    .btn.danger{ border-color: rgba(255,92,122,.45); background: rgba(255,92,122,.12); }
    .btn.toggleOn{ border-color: rgba(166,255,203,.55); background: rgba(166,255,203,.14); }

    .slider{
      flex: 1;
      min-width: 140px;
      display:flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 12px;
    }
    .slider label{ font-size: 11.5px; color: var(--muted); display:flex; justify-content: space-between; gap: 10px; }
    .slider input[type="range"]{ width: 100%; }
    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(180deg, rgba(103,213,255,1), rgba(78,160,255,1));
      border: 1px solid rgba(255,255,255,.35);
      box-shadow: 0 8px 18px rgba(103,213,255,.25);
      cursor: pointer;
    }

    .main{
      position: relative;
      border-radius: var(--radius);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: var(--shadow);
      background: rgba(0,0,0,.18);
      min-width: 0;
    }
    canvas{ display:block; width:100%; height:100%; }

    .hud{ position:absolute; inset: 0; pointer-events: none; display:flex; flex-direction: column; justify-content: space-between; }
    .topbar{ padding: 12px; display:flex; align-items:flex-start; justify-content: space-between; gap: 10px; }

    .panel{
      pointer-events: auto;
      background: rgba(15,24,51,.70);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 12px;
      max-width: 520px;
      backdrop-filter: blur(10px);
    }
    .panel h2{ margin: 0 0 6px 0; font-size: 16px; letter-spacing: .2px; }
    .panel p{ margin: 0; color: var(--muted); font-size: 12.5px; line-height: 1.45; }

    .mini{
      pointer-events: auto;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
      width: 280px;
    }
    .mini .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      font-family: var(--mono);
    }
    .mini .kv b{ color: var(--text); font-family: var(--font); font-size: 12px; }

    .bottombar{ padding: 12px; display:flex; gap: 10px; align-items:flex-end; justify-content: space-between; pointer-events: none; }

    .legend{
      pointer-events:auto;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
      max-width: 520px;
    }
    .chips{ display:flex; flex-wrap: wrap; gap: 8px; }
    .chip{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      font-size: 12px;
      color: var(--muted);
    }
    .dot{ width:10px; height:10px; border-radius:50%; box-shadow: 0 0 0 2px rgba(255,255,255,.12) inset; }

    .toast{
      pointer-events:auto;
      display:none;
      align-items:center;
      gap: 10px;
      background: rgba(15,24,51,.78);
      border: 1px solid rgba(103,213,255,.18);
      border-radius: 14px;
      padding: 10px 12px;
      max-width: 420px;
    }
    .toast.show{ display:flex; }
    .toast .hint{ font-size: 12.5px; color: var(--muted); line-height: 1.35; }

    .labelLayer{ position:absolute; inset: 0; pointer-events: none; overflow: hidden; }
    .label{
      position:absolute;
      transform: translate(-50%, -50%);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 12px;
      color: rgba(255,255,255,.92);
      background: rgba(15,24,51,.72);
      border: 1px solid rgba(255,255,255,.10);
      white-space: nowrap;
      box-shadow: 0 12px 28px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .label .k{ color: var(--accent); font-weight: 700; margin-right: 6px; }

    @media (max-width: 980px){
      body{ overflow:auto; }
      .app{ height:auto; min-height:100%; grid-template-columns: 1fr; }
      .main{ height: 62vh; }
    }
  </style>

  <!-- Import map: Three + Addons (OrbitControls, GLTFLoader). Cambia per offline totale come da commento sopra -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div class="app">
    <!-- Sidebar: titolo + navigazione + controlli -->
    <aside class="sidebar">
      <div class="brand">
        <h1>Presentazione 3D — Biologia</h1>
        <p>Apparato cardiocircolatorio & sistema nervoso. Modelli 3D didattici con animazioni e controlli per proiezione.</p>
      </div>

      <div class="nav" id="nav">
        <button class="active" data-scene="heart">
          <div class="title">Cuore & Circolazione</div>
          <div class="desc">Battito, camere, valvole e flussi (rosso/blu).</div>
        </button>
        <button data-scene="neuron">
          <div class="title">Neurone</div>
          <div class="desc">Dendriti, assone, mielina e conduzione saltatoria.</div>
        </button>
        <button data-scene="synapse">
          <div class="title">Sinapsi</div>
          <div class="desc">Rilascio neurotrasmettitori step-by-step.</div>
        </button>
        <button data-scene="nervous">
          <div class="title">Sistema Nervoso</div>
          <div class="desc">SNC + SNP, somatico/autonomo, arco riflesso.</div>
        </button>
        <button data-scene="action">
          <div class="title">Impulsi Elettrici</div>
          <div class="desc">Potenziale d’azione + Na⁺/K⁺ + rete neurale.</div>
        </button>
      </div>

      <div class="controls">
        <div class="row">
          <button class="btn primary" id="btnPlay">Play</button>
          <button class="btn" id="btnPause">Pause</button>
          <button class="btn danger" id="btnReset">Reset</button>
        </div>
        <div class="row">
          <div class="slider">
            <label>
              <span>Velocità animazioni</span>
              <span id="speedVal">1.00×</span>
            </label>
            <input id="speed" type="range" min="0.25" max="2.5" step="0.05" value="1.00" />
          </div>
        </div>
        <div class="row">
          <button class="btn toggleOn" id="btnLabels">Labels: ON</button>
          <button class="btn" id="btnHelp">Guida</button>
        </div>
      </div>
    </aside>

    <!-- Area principale: canvas WebGL + HUD -->
    <main class="main" id="main">
      <canvas id="c"></canvas>

      <!-- HUD: pannello info + mini stats + legenda + toast -->
      <div class="hud">
        <div class="topbar">
          <div class="panel" id="panel">
            <h2 id="panelTitle">Cuore & Apparato cardiocircolatorio</h2>
            <p id="panelText">Ruota con il mouse/touch, zoom con rotellina/pinch. Osserva sistole/diastole, valvole e flussi: rosso = sangue ossigenato, blu = deossigenato.</p>
          </div>

          <div class="mini">
            <div class="kv">
              <b>Sezione</b><span id="kvScene">heart</span>
              <b>Animazione</b><span id="kvState">playing</span>
              <b>Tempo</b><span id="kvTime">0.00 s</span>
              <b>FPS</b><span id="kvFps">—</span>
            </div>
          </div>
        </div>

        <div class="bottombar">
          <div class="legend" id="legend">
            <div class="chips" id="chips"></div>
          </div>

          <div class="toast" id="toast">
            <div class="hint" id="toastText"></div>
          </div>
        </div>
      </div>

      <!-- Layer per etichette HTML ancorate agli oggetti 3D -->
      <div class="labelLayer" id="labelLayer"></div>
    </main>
  </div>

  <!--
    JavaScript (ES Module):
    - Setup di Three.js, camera, luci, controlli
    - Manager delle scene richieste
    - Animazioni e interazioni UI
    - Caricamento modelli GLB dal repository locale
  -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /***********************************************************************
     * UTIL & UI
     ***********************************************************************/
    const $ = (sel)=>document.querySelector(sel);
    const $$ = (sel)=>Array.from(document.querySelectorAll(sel));

    const state = {
      sceneKey: 'heart',
      playing: true,
      speed: 1.0,
      labels: true,
      t: 0,
      last: performance.now(),
      fps: 0,
      _fpsAcc: 0,
      _fpsCount: 0
    };

    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(a,b,x){
      const t = clamp((x-a)/(b-a), 0, 1);
      return t*t*(3-2*t);
    }

    function setToast(msg, ms=2300){
      const toast = $('#toast');
      $('#toastText').textContent = msg;
      toast.classList.add('show');
      clearTimeout(setToast._tm);
      setToast._tm = setTimeout(()=>toast.classList.remove('show'), ms);
    }

    function setLegend(chips){
      const el = $('#chips');
      el.innerHTML = '';
      for (const c of chips){
        const chip = document.createElement('div');
        chip.className = 'chip';
        const dot = document.createElement('div');
        dot.className = 'dot';
        dot.style.background = c.color;
        chip.appendChild(dot);
        const span = document.createElement('span');
        span.textContent = c.label;
        chip.appendChild(span);
        el.appendChild(chip);
      }
    }

    /***********************************************************************
     * THREE: RENDERER / CAMERA / CONTROLS / LIGHTS
     ***********************************************************************/
    const canvas = $('#c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1020, 0.028);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 300);
    camera.position.set(0, 1.8, 7.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 2.4;
    controls.maxDistance = 22;
    controls.target.set(0, 1.05, 0);

    const amb = new THREE.AmbientLight(0x8aa3ff, 0.22);
    scene.add(amb);

    const key = new THREE.DirectionalLight(0xffffff, 1.25);
    key.position.set(4, 6, 3);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x67d5ff, 0.55);
    fill.position.set(-6, 2, 4);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(0xa6ffcb, 0.35);
    rim.position.set(0, 5, -8);
    scene.add(rim);

    const grid = new THREE.GridHelper(24, 24, 0x24315c, 0x16204a);
    grid.position.y = -0.15;
    grid.material.transparent = true;
    grid.material.opacity = 0.18;
    scene.add(grid);

    const deco = new THREE.Group();
    scene.add(deco);
    (function addDeco(){
      const g = new THREE.SphereGeometry(0.06, 16, 16);
      for (let i=0;i<42;i++){ 
        const m = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.55 + Math.random()*0.15, 0.85, 0.62),
          emissive: 0x0b1020,
          roughness: 0.25,
          metalness: 0.25,
          transparent: true,
          opacity: 0.55
        });
        const s = new THREE.Mesh(g, m);
        s.position.set((Math.random()-0.5)*18, Math.random()*9, (Math.random()-0.5)*18);
        s.scale.setScalar(0.7 + Math.random()*1.7);
        deco.add(s);
      }
    })();

    function resize(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    /***********************************************************************
     * LABELS (overlay HTML ancorati a oggetti 3D)
     ***********************************************************************/
    const labelLayer = $('#labelLayer');
    const labelPool = new Map();
    const labelAnchors = []; // {key, object3D, text, color}

    function clearLabels(){
      labelAnchors.length = 0;
      labelLayer.innerHTML = '';
      labelPool.clear();
    }

    function addLabel(key, object3D, text, color='#67d5ff'){
      labelAnchors.push({ key, object3D, text, color });
      const div = document.createElement('div');
      div.className = 'label';
      div.innerHTML = `<span class="k">●</span>${text}`;
      div.querySelector('.k').style.color = color;
      labelLayer.appendChild(div);
      labelPool.set(key, div);
    }

    function updateLabels(){
      labelLayer.style.display = state.labels ? 'block' : 'none';
      if (!state.labels) return;

      const rect = canvas.getBoundingClientRect();
      for (const a of labelAnchors){
        const div = labelPool.get(a.key);
        if (!div) continue;
        const pos = new THREE.Vector3();
        a.object3D.getWorldPosition(pos);
        pos.project(camera);

        const visible = pos.z < 1;
        div.style.display = visible ? 'block' : 'none';
        if (!visible) continue;

        const x = (pos.x * 0.5 + 0.5) * rect.width;
        const y = (-pos.y * 0.5 + 0.5) * rect.height;
        div.style.left = `${x}px`;
        div.style.top  = `${y}px`;
      }
    }

    /***********************************************************************
     * HELPERS (materiali, particelle flusso, caricamento GLB)
     ***********************************************************************/
    function matSoft(color, emissive=0x050813){
      return new THREE.MeshStandardMaterial({
        color,
        emissive,
        roughness: 0.28,
        metalness: 0.18
      });
    }
    function matGlass(color, opacity=0.22){
      return new THREE.MeshPhysicalMaterial({
        color,
        roughness: 0.08,
        metalness: 0.0,
        transmission: 1.0,
        thickness: 0.25,
        transparent: true,
        opacity,
        ior: 1.35
      });
    }
    function makeArrow(color=0x67d5ff){
      const g1 = new THREE.CylinderGeometry(0.03, 0.03, 0.8, 18);
      const g2 = new THREE.ConeGeometry(0.09, 0.22, 20);
      const m = new THREE.MeshStandardMaterial({ color, emissive: 0x060b18, roughness: 0.35, metalness: 0.2 });
      const shaft = new THREE.Mesh(g1, m);
      const head = new THREE.Mesh(g2, m);
      head.position.y = 0.51;
      const group = new THREE.Group();
      group.add(shaft, head);
      return group;
    }

    class FlowParticles {
      constructor(curve, opts){
        this.curve = curve;
        this.count = opts.count ?? 120;
        this.speed = opts.speed ?? 0.15;
        this.size = opts.size ?? 0.04;
        this.color = opts.color ?? 0xff3b59;
        this.opacity = opts.opacity ?? 0.9;
        this.phase = opts.phase ?? 0;
        this.jitter = opts.jitter ?? 0.03;
        this.group = new THREE.Group();

        const geom = new THREE.SphereGeometry(this.size, 12, 12);
        const mat = new THREE.MeshStandardMaterial({
          color: this.color,
          emissive: new THREE.Color(this.color).multiplyScalar(0.25),
          roughness: 0.25,
          metalness: 0.2,
          transparent: true,
          opacity: this.opacity
        });

        this.meshes = [];
        for (let i=0;i<this.count;i++){
          const m = new THREE.Mesh(geom, mat);
          m.userData.u = (i/this.count + this.phase) % 1;
          this.group.add(m);
          this.meshes.push(m);
        }
      }
      reset(){
        for (let i=0;i<this.meshes.length;i++){
          this.meshes[i].userData.u = (i/this.meshes.length + this.phase) % 1;
        }
      }
      update(dt, speedMul=1){
        const v = dt * this.speed * speedMul;
        for (const m of this.meshes){
          m.userData.u = (m.userData.u + v) % 1;
          const u = m.userData.u;
          const p = this.curve.getPointAt(u);
          const t = this.curve.getTangentAt(u);
          m.position.copy(p);
          const n = new THREE.Vector3(-t.z, 0, t.x).normalize();
          m.position.addScaledVector(n, (Math.sin((u*12 + m.id)*2.1)*0.5 + (Math.random()-0.5))*this.jitter);
        }
      }
    }

    const gltfLoader = new GLTFLoader();
    const modelCache = new Map();
    async function loadGLB(url){
      if (modelCache.has(url)) return modelCache.get(url).clone(true);
      return new Promise((resolve, reject)=>{
        gltfLoader.load(url, (gltf)=>{
          const root = gltf.scene || gltf.scenes?.[0];
          modelCache.set(url, root);
          resolve(root.clone(true));
        }, undefined, (err)=>{
          console.error('GLB load error', err);
          setToast('Errore nel caricamento modello: ' + url, 2400);
          reject(err);
        });
      });
    }

    /***********************************************************************
     * SCENE MANAGER
     ***********************************************************************/
    const root = new THREE.Group();
    scene.add(root);

    const scenes = {};
    let active = null;

    function setScene(key){
      root.clear();
      clearLabels();

      state.sceneKey = key;
      $('#kvScene').textContent = key;

      controls.target.set(0, 1.05, 0);
      controls.update();

      active = scenes[key];
      if (!active) return;

      active.build(root);

      $('#panelTitle').textContent = active.title;
      $('#panelText').textContent = active.text;
      setLegend(active.legendChips || []);

      $$('#nav button').forEach(b => b.classList.toggle('active', b.dataset.scene === key));
      setToast(active.toast ?? 'Suggerimento: trascina per ruotare, rotellina/pinch per zoom.', 2600);
    }

    function reset(){
      state.t = 0;
      if (active && active.reset) active.reset();
      setToast('Animazione reimpostata.', 1600);
    }

    /***********************************************************************
     * SCENA 1: CUORE (usa jantung_manusia.glb)
     ***********************************************************************/
    scenes.heart = (function(){
      let heartGroup, heartModel, valves, flowBlue, flowRed, arrows;
      let beatPhase = 0;
      let curveBlue, curveRed;

      async function build(parent){
        heartGroup = new THREE.Group();
        parent.add(heartGroup);

        // Carica modello GLB del cuore
        heartModel = await loadGLB('jantung_manusia.glb').catch(()=>new THREE.Group());
        heartModel.traverse(o=>{
          if (o.isMesh){
            o.material = matSoft(0xd9153a, 0x150612);
            o.castShadow = false; o.receiveShadow = false;
          }
        });
        heartModel.position.set(0, 1.15, 0);
        heartModel.scale.set(1.2, 1.2, 1.2);
        heartGroup.add(heartModel);

        // Guscio vetroso per dare profondità
        const shellGeom = new THREE.SphereGeometry(1.55, 42, 36);
        shellGeom.scale(1.0, 1.2, 0.85);
        const shell = new THREE.Mesh(shellGeom, matGlass(0xff3b59, 0.10));
        shell.position.set(0, 1.15, 0);
        heartGroup.add(shell);

        // Indicatori camere (semplificati per labeling didattico)
        const chambers = new THREE.Group();
        heartGroup.add(chambers);
        const atrioDx = new THREE.Mesh(new THREE.SphereGeometry(0.46, 32, 24), matSoft(0x4ea0ff, 0x060b18));
        const atrioSx = new THREE.Mesh(new THREE.SphereGeometry(0.46, 32, 24), matSoft(0xff3b59, 0x120613));
        const ventDx  = new THREE.Mesh(new THREE.SphereGeometry(0.62, 36, 26), matSoft(0x2e6bff, 0x050813));
        const ventSx  = new THREE.Mesh(new THREE.SphereGeometry(0.62, 36, 26), matSoft(0xd9153a, 0x150612));
        atrioDx.position.set(-0.35, 1.55, 0.28);
        atrioSx.position.set( 0.35, 1.55,-0.28);
        ventDx.position.set( -0.42, 0.92, 0.18);
        ventSx.position.set( 0.42, 0.92,-0.18);
        ventSx.scale.set(1.0, 1.1, 0.95);
        chambers.add(atrioDx, atrioSx, ventDx, ventSx);

        addLabel('ad', atrioDx, 'Atrio destro (deossigenato)', '#4ea0ff');
        addLabel('vd', ventDx,  'Ventricolo destro → arteria polmonare', '#2e6bff');
        addLabel('as', atrioSx, 'Atrio sinistro (ossigenato)', '#ff3b59');
        addLabel('vs', ventSx,  'Ventricolo sinistro → aorta', '#ff3b59');

        // Valvole semplificate (dischi trasparenti)
        valves = new THREE.Group();
        heartGroup.add(valves);
        const gValve = new THREE.CircleGeometry(0.18, 32);
        const mValve = new THREE.MeshStandardMaterial({
          color: 0xe8eeff, emissive: 0x0b1020, roughness: 0.25, metalness: 0.25,
          side: THREE.DoubleSide, transparent: true, opacity: 0.85
        });
        const tricuspide = new THREE.Mesh(gValve, mValve); tricuspide.position.set(-0.40, 1.23, 0.22); tricuspide.rotation.x = Math.PI/2;
        const mitrale    = new THREE.Mesh(gValve, mValve); mitrale.position.set(0.40, 1.23, -0.22);   mitrale.rotation.x = Math.PI/2;
        const polmonare  = new THREE.Mesh(gValve, mValve); polmonare.position.set(-0.55, 1.02, -0.48); polmonare.rotation.z = Math.PI/2;
        const aortica    = new THREE.Mesh(gValve, mValve); aortica.position.set(0.55, 1.02,  0.48);    aortica.rotation.z = Math.PI/2;
        valves.add(tricuspide, mitrale, polmonare, aortica);

        addLabel('v1', tricuspide, 'Valvola tricuspide', '#a6ffcb');
        addLabel('v2', mitrale, 'Valvola mitrale', '#a6ffcb');
        addLabel('v3', polmonare, 'Valvola polmonare', '#a6ffcb');
        addLabel('v4', aortica, 'Valvola aortica', '#a6ffcb');

        // Frecce per circolazione polmonare e sistemica
        arrows = new THREE.Group();
        heartGroup.add(arrows);
        const arrPulm = makeArrow(0x2e6bff); arrPulm.position.set(-1.35, 1.62, -0.55); arrPulm.rotation.z = 0.35; arrPulm.rotation.x = -0.25;
        const arrSys  = makeArrow(0xff3b59); arrSys.position.set( 1.25, 1.80,  0.55); arrSys.rotation.z = -0.35; arrSys.rotation.x = -0.20;
        arrows.add(arrPulm, arrSys);

        // Percorsi di flusso (curve Catmull)
        curveBlue = new THREE.CatmullRomCurve3([
          new THREE.Vector3(-1.3, 2.2, 0.65),
          new THREE.Vector3(-0.95, 1.95, 0.48),
          new THREE.Vector3(-0.55, 1.75, 0.35),
          atrioDx.position.clone(),
          new THREE.Vector3(-0.40, 1.23, 0.22),
          ventDx.position.clone(),
          new THREE.Vector3(-0.55, 1.02, -0.48),
          new THREE.Vector3(-0.95, 1.25, -0.75),
          new THREE.Vector3(-1.55, 1.65, -0.65),
          new THREE.Vector3(-2.0, 1.95, -0.35)
        ]);
        curveRed = new THREE.CatmullRomCurve3([
          new THREE.Vector3(2.0, 1.95, 0.35),
          new THREE.Vector3(1.55, 1.65, 0.65),
          new THREE.Vector3(0.95, 1.35, 0.35),
          atrioSx.position.clone(),
          new THREE.Vector3(0.40, 1.23, -0.22),
          ventSx.position.clone(),
          new THREE.Vector3(0.55, 1.02, 0.48),
          new THREE.Vector3(0.95, 1.25, 0.85),
          new THREE.Vector3(1.55, 1.85, 0.55),
          new THREE.Vector3(1.8, 2.35, 0.05)
        ]);

        flowBlue = new FlowParticles(curveBlue, { count: 140, speed: 0.10, size: 0.040, color: 0x2e6bff, opacity: 0.95, jitter: 0.035, phase: 0.15 });
        flowRed  = new FlowParticles(curveRed,  { count: 140, speed: 0.10, size: 0.040, color: 0xff3b59, opacity: 0.95, jitter: 0.035, phase: 0.65 });
        heartGroup.add(flowBlue.group, flowRed.group);

        heartGroup.rotation.y = 0.65;

        $('#panelTitle').textContent = 'Cuore & Apparato cardiocircolatorio';
        $('#panelText').textContent = 'Modello GLB del cuore con 4 camere, valvole semplificate e flussi animati (rosso/blu). Ruota e zooma liberamente.';
      }

      function update(dt){
        beatPhase += dt * 2.2 * state.speed;
        const beat = 0.5 + 0.5*Math.sin(beatPhase);
        const lub = Math.pow(Math.max(0, Math.sin(beatPhase)), 2.6);
        const dub = Math.pow(Math.max(0, Math.sin(beatPhase + 1.55)), 4.2);
        const pulse = clamp(0.15 + 0.85*(0.62*lub + 0.38*dub), 0, 1);

        const scale = 1.0 - 0.09*pulse;
        heartGroup.scale.set(scale, 1.0 - 0.06*pulse, scale);

        const systole = smoothstep(0.40, 0.78, beat);
        const diastole = 1.0 - systole;

        const [tric, mitr, pulm, aort] = valves.children;
        tric.rotation.z = lerp(0.0, 0.9, diastole);
        mitr.rotation.z = lerp(0.0, -0.9, diastole);
        pulm.rotation.y = lerp(0.0, 0.9, systole);
        aort.rotation.y = lerp(0.0, -0.9, systole);

        const flowMul = 0.65 + 1.05*systole;
        flowBlue.update(dt, flowMul);
        flowRed.update(dt, flowMul);

        arrows.children[0].scale.setScalar(1.0 + 0.08*Math.sin(beatPhase*1.3));
        arrows.children[1].scale.setScalar(1.0 + 0.08*Math.sin(beatPhase*1.3 + 1.1));
      }

      function reset(){
        beatPhase = 0;
        if (flowBlue) flowBlue.reset();
        if (flowRed)  flowRed.reset();
        heartGroup.scale.set(1,1,1);
        heartGroup.rotation.y = 0.65;
      }

      return {
        title: 'Cuore & Apparato cardiocircolatorio',
        text: 'Modello 3D GLB con animazione sistole/diastole, valvole sincronizzate e flussi: rosso = ossigenato, blu = deossigenato.',
        toast: 'Cuore: osserva le valvole e i flussi rosso/blu.',
        legendChips: [
          { label: 'Sangue ossigenato', color: '#ff3b59' },
          { label: 'Sangue deossigenato', color: '#2e6bff' },
          { label: 'Valvole', color: '#a6ffcb' }
        ],
        build, update, reset
      };
    })();

    /***********************************************************************
     * SCENA 2: NEURONE (usa neuron.glb) + conduzione saltatoria
     ***********************************************************************/
    scenes.neuron = (function(){
      let g, neuronModel, myelin, nodes, impulse;
      let curve, flow;
      let phase = 0;

      async function build(parent){
        g = new THREE.Group();
        parent.add(g);

        neuronModel = await loadGLB('neuron.glb').catch(()=>new THREE.Group());
        neuronModel.traverse(o=>{
          if (o.isMesh){
            o.material = matSoft(0xa6ffcb, 0x06120a);
          }
        });
        neuronModel.position.set(-1.6, 1.2, 0);
        neuronModel.scale.set(1.2, 1.2, 1.2);
        g.add(neuronModel);

        // Curva dell'assone (per impulso)
        curve = new THREE.CatmullRomCurve3([
          neuronModel.position.clone().add(new THREE.Vector3(0.55, -0.10, 0.0)),
          new THREE.Vector3(-0.2, 0.9, 0.1),
          new THREE.Vector3(1.2, 1.0, -0.25),
          new THREE.Vector3(2.8, 1.2, 0.25),
          new THREE.Vector3(4.3, 1.05, 0.0)
        ]);

        // Tubo assone semitrasparente
        const axon = new THREE.Mesh(new THREE.TubeGeometry(curve, 160, 0.085, 16, false), matSoft(0x67d5ff, 0x061020));
        g.add(axon);

        // Guaina mielinica + nodi di Ranvier
        myelin = new THREE.Group();
        nodes = new THREE.Group();
        g.add(myelin, nodes);

        const ringMat = matSoft(0xe8eeff, 0x050813);
        const nodeMat = matSoft(0xff5c7a, 0x12060e);
        const segments = 12;
        for (let i=0;i<segments;i++){
          const u0 = i/(segments);
          const u1 = (i+1)/(segments);
          const uMid = (u0+u1)*0.5;
          const p = curve.getPointAt(uMid);
          const t = curve.getTangentAt(uMid).normalize();

          const ring = new THREE.Mesh(new THREE.CylinderGeometry(0.145, 0.145, 0.30, 22, 1, true), ringMat);
          ring.position.copy(p);
          ring.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), t);
          ring.rotateX(Math.PI/2);
          myelin.add(ring);

          const node = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.020, 10, 22), nodeMat);
          const pn = curve.getPointAt(u1);
          const tn = curve.getTangentAt(u1).normalize();
          node.position.copy(pn);
          node.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), tn);
          node.rotateX(Math.PI/2);
          nodes.add(node);
        }

        // Impulso visivo + flusso particelle
        flow = new FlowParticles(curve, { count: 90, speed: 0.16, size: 0.032, color: 0xffd166, opacity: 0.95, jitter: 0.01, phase: 0.0 });
        g.add(flow.group);

        impulse = new THREE.Mesh(new THREE.SphereGeometry(0.10, 18, 16), new THREE.MeshStandardMaterial({
          color: 0xffd166, emissive: 0xffa200, roughness: 0.15, metalness: 0.15
        }));
        g.add(impulse);

        // Labels principali
        addLabel('soma', neuronModel, 'Soma + dendriti (modello GLB)', '#a6ffcb');
        addLabel('axon', axon, 'Assone (conduzione)', '#67d5ff');
        addLabel('my', myelin, 'Guaina mielinica', '#e8eeff');
        addLabel('node', nodes, 'Nodi di Ranvier', '#ff5c7a');

        g.rotation.y = -0.25;
        controls.target.set(1.1, 1.1, 0);
        camera.position.set(0.2, 1.9, 8.2);

        $('#panelTitle').textContent = 'Neurone (struttura + conduzione saltatoria)';
        $('#panelText').textContent = 'Modello GLB del neurone. Impulso lungo l’assone con guaina mielinica e nodi di Ranvier: la conduzione è “saltatoria”.';
      }

      function update(dt){
        phase += dt * 0.9 * state.speed;

        // Impulso che scorre lungo l’assone
        const u = (phase*0.22) % 1;
        impulse.position.copy(curve.getPointAt(u));

        // Boost visivo ai nodi quando l’impulso passa
        let boost = 1.0;
        for (let i=0;i<nodes.children.length;i++){ 
          const un = (i+1)/12;
          const d = Math.min(Math.abs(u-un), 1-Math.abs(u-un));
          boost += Math.exp(-(d*d)/0.0008) * 1.8;
        }
        flow.update(dt, (0.6 + 0.6*boost));

        for (let i=0;i<nodes.children.length;i++){ 
          const un = (i+1)/12;
          const d = Math.min(Math.abs(u-un), 1-Math.abs(u-un));
          const s = 1.0 + Math.exp(-(d*d)/0.0007) * 0.9;
          nodes.children[i].scale.setScalar(s);
        }
      }

      function reset(){
        phase = 0;
        if (flow) flow.reset();
      }

      return {
        title: 'Neurone (struttura + conduzione saltatoria)',
        text: 'Soma, dendriti e assone con mielina. L’impulso “salta” tra i nodi di Ranvier.',
        toast: 'Neurone: usa Labels per riconoscere le parti principali.',
        legendChips: [
          { label: 'Impulso (segnale)', color: '#ffd166' },
          { label: 'Assone', color: '#67d5ff' },
          { label: 'Mielina', color: '#e8eeff' },
          { label: 'Nodi di Ranvier', color: '#ff5c7a' },
        ],
        build, update, reset
      };
    })();

    /***********************************************************************
     * SCENA 3: SINAPSI (procedurale, zoom sulla giunzione)
     ***********************************************************************/
    scenes.synapse = (function(){
      let g, pre, post, cleftPlane, vesicles, receptors, nts;
      let phase = 0;
      let step = 0;
      let stepT = 0;

      function build(parent){
        g = new THREE.Group();
        parent.add(g);

        const preMat = matSoft(0x67d5ff, 0x061020);
        const postMat = matSoft(0xa6ffcb, 0x06120a);

        pre = new THREE.Mesh(new THREE.CapsuleGeometry(1.35, 0.8, 16, 28), preMat);
        pre.position.set(-1.35, 1.2, 0);
        pre.rotation.z = Math.PI/2;
        g.add(pre);

        post = new THREE.Mesh(new THREE.CapsuleGeometry(1.55, 0.9, 16, 28), postMat);
        post.position.set(1.45, 1.2, 0);
        post.rotation.z = Math.PI/2;
        g.add(post);

        cleftPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(0.55, 2.4),
          new THREE.MeshStandardMaterial({ color: 0xe8eeff, transparent: true, opacity: 0.08, side: THREE.DoubleSide })
        );
        cleftPlane.position.set(0.05, 1.2, 0);
        cleftPlane.rotation.y = Math.PI/2;
        g.add(cleftPlane);

        vesicles = new THREE.Group();
        g.add(vesicles);

        const vesMat = matGlass(0xffd166, 0.22);
        for (let i=0;i<14;i++){
          const v = new THREE.Mesh(new THREE.SphereGeometry(0.16, 18, 14), vesMat);
          v.position.set(-1.35 + (Math.random()*0.8-0.4), 1.2 + (Math.random()*1.0-0.5), (Math.random()*0.9-0.45));
          v.userData.home = v.position.clone();
          vesicles.add(v);
        }

        receptors = new THREE.Group();
        g.add(receptors);
        const recMat = matSoft(0xff5c7a, 0x14060e);
        for (let i=0;i<10;i++){
          const r = new THREE.Mesh(new THREE.TorusGeometry(0.13, 0.04, 10, 18), recMat);
          r.position.set(0.92 + Math.random()*0.35, 1.2 + (Math.random()*1.6-0.8), (Math.random()*0.9-0.45));
          r.rotation.y = Math.PI/2;
          receptors.add(r);
        }

        nts = [];
        const ntGeom = new THREE.SphereGeometry(0.05, 12, 10);
        const ntMat = new THREE.MeshStandardMaterial({ color: 0xffd166, emissive: 0xffa200, roughness: 0.25, metalness: 0.1, transparent: true, opacity: 0.95 });
        for (let i=0;i<140;i++){
          const nt = new THREE.Mesh(ntGeom, ntMat);
          nt.visible = false;
          nt.position.set(-0.8, 1.2, 0);
          nt.userData.v = new THREE.Vector3();
          nt.userData.life = 0;
          nts.push(nt);
          g.add(nt);
        }

        addLabel('pre', pre, 'Terminale presinaptico', '#67d5ff');
        addLabel('ves', vesicles, 'Vescicole (neurotrasmettitori)', '#ffd166');
        addLabel('cleft', cleftPlane, 'Fessura sinaptica', '#e8eeff');
        addLabel('rec', receptors, 'Recettori postsinaptici', '#ff5c7a');
        addLabel('post', post, 'Neurone post‑sinaptico', '#a6ffcb');

        g.rotation.y = 0.35;
        controls.target.set(0.15, 1.2, 0);
        camera.position.set(0.2, 1.9, 8.0);

        setStep(0);

        $('#panelTitle').textContent = 'Sinapsi chimica (step-by-step)';
        $('#panelText').textContent = 'Arrivo del segnale → esocitosi → diffusione dei neurotrasmettitori → legame ai recettori e risposta postsinaptica.';
      }

      function setStep(s){
        step = s;
        stepT = 0;
        const messages = [
          'Step 1/4: Arrivo del segnale al terminale presinaptico.',
          'Step 2/4: Vescicole → fusione con membrana (esocitosi).',
          'Step 3/4: Neurotrasmettitori attraversano la fessura.',
          'Step 4/4: Legame ai recettori → risposta postsinaptica.'
        ];
        setToast(messages[step], 2400);
      }

      function emitNT(burst=32){
        let n = burst;
        for (const nt of nts){
          if (n<=0) break;
          if (nt.visible) continue;
          nt.visible = true;
          nt.position.set(-0.55, 1.2 + (Math.random()-0.5)*0.35, (Math.random()-0.5)*0.25);
          nt.userData.v.set(
            1.2 + Math.random()*0.9,
            (Math.random()-0.5)*0.7,
            (Math.random()-0.5)*0.6
          );
          nt.userData.life = 1.0;
          n--;
        }
      }

      function update(dt){
        phase += dt * state.speed;
        stepT += dt * (0.35 + 0.35*state.speed);

        if (stepT > 1.0){
          setStep((step + 1) % 4);
        }

        pre.scale.set(1, 1, 1 + 0.02*Math.sin(phase*2.1));
        post.scale.set(1, 1, 1 + 0.02*Math.sin(phase*2.1 + 1.0));

        if (step === 0){
          for (const v of vesicles.children){
            v.position.copy(v.userData.home).add(new THREE.Vector3(
              (Math.sin(phase*3 + v.id)*0.03),
              (Math.cos(phase*2 + v.id)*0.03),
              (Math.sin(phase*2.4 + v.id)*0.03)
            ));
          }
        } else if (step === 1){
          const k = smoothstep(0.05, 0.95, stepT);
          let i=0;
          for (const v of vesicles.children){
            const target = new THREE.Vector3(-0.75, 1.2 + (i-6)*0.08, (i%3-1)*0.12);
            v.position.copy(v.userData.home).lerp(target, k);
            v.scale.setScalar(1.0 - 0.35*k);
            i++;
          }
          if (stepT > 0.45 && stepT < 0.55) emitNT(44);
        } else if (step === 2){
          if (Math.random() < 0.18*state.speed) emitNT(8);
        } else if (step === 3){
          const glow = 0.6 + 0.4*Math.sin(phase*4.0);
          for (const r of receptors.children){
            r.scale.setScalar(1.0 + 0.25*glow);
          }
        }

        for (const nt of nts){
          if (!nt.visible) continue;
          nt.position.addScaledVector(nt.userData.v, dt * 0.65 * state.speed);
          nt.userData.v.multiplyScalar(0.985);
          nt.userData.v.x = lerp(nt.userData.v.x, 0.55, 0.02);

          if (nt.position.x > 0.95){
            let best = null, bestD = 1e9;
            for (const r of receptors.children){
              const d = r.position.distanceTo(nt.position);
              if (d < bestD){ bestD = d; best = r; }
            }
            if (best && bestD < 0.35){
              best.scale.setScalar(1.65);
            }
            nt.visible = false;
          }

          nt.userData.life -= dt * 0.25 * state.speed;
          if (nt.userData.life <= 0){
            nt.visible = false;
          }
        }
      }

      function reset(){
        phase = 0;
        setStep(0);
        for (const v of vesicles.children){
          v.position.copy(v.userData.home);
          v.scale.setScalar(1);
        }
        for (const nt of nts) nt.visible = false;
        for (const r of receptors.children) r.scale.setScalar(1);
      }

      return {
        title: 'Sinapsi chimica (step-by-step)',
        text: 'Esocitosi delle vescicole, diffusione dei neurotrasmettitori e legame ai recettori, con animazione in 4 step.',
        toast: 'Sinapsi: la sequenza si ripete. Usa Reset per tornare allo Step 1.',
        legendChips: [
          { label: 'Vescicole', color: '#ffd166' },
          { label: 'Neurotrasmettitori', color: '#ffb703' },
          { label: 'Recettori', color: '#ff5c7a' },
          { label: 'Post‑sinaptico', color: '#a6ffcb' },
        ],
        build, update, reset
      };
    })();

    /***********************************************************************
     * SCENA 4: SISTEMA NERVOSO (usa human_brain.glb)
     ***********************************************************************/
    scenes.nervous = (function(){
      let g, brainModel, spinal, somatic, autonomic, pulses, reflex;
      let phase = 0;

      async function build(parent){
        g = new THREE.Group();
        parent.add(g);

        brainModel = await loadGLB('human_brain.glb').catch(async()=>await loadGLB('brain_project.glb').catch(()=>new THREE.Group()));
        brainModel.traverse(o=>{
          if (o.isMesh){
            o.material = matSoft(0xff5c7a, 0x14060e);
          }
        });
        brainModel.position.set(0, 2.15, 0);
        brainModel.scale.set(1.0, 1.0, 1.0);
        g.add(brainModel);

        // Midollo spinale (cylinder trasparente)
        spinal = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.16, 2.9, 18, 1, true), matSoft(0xe8eeff, 0x050813));
        spinal.position.set(0, 0.75, 0);
        g.add(spinal);

        const nerves = new THREE.Group();
        somatic = new THREE.Group();
        autonomic = new THREE.Group();
        nerves.add(somatic, autonomic);
        g.add(nerves);

        const somMat = matSoft(0x67d5ff, 0x061020);
        const autMat = matSoft(0xa6ffcb, 0x06120a);

        function addNerve(mat, points, radius){
          const curve = new THREE.CatmullRomCurve3(points);
          const mesh = new THREE.Mesh(new THREE.TubeGeometry(curve, 100, radius, 12, false), mat);
          return { curve, mesh };
        }

        const somCurves = [];
        const autCurves = [];
        const base = new THREE.Vector3(0, 1.1, 0);

        const targetsSom = [
          new THREE.Vector3(-2.6, 1.4, 0.6),
          new THREE.Vector3( 2.6, 1.4,-0.6),
          new THREE.Vector3(-2.2, 0.3, 0.9),
          new THREE.Vector3( 2.2, 0.3,-0.9),
        ];

        // [Resto del codice di configurazione per il sistema nervoso]
        // Da completare...
      }

      return {
        title: 'Sistema Nervoso',
        text: 'Modello 3D del cervello e del sistema nervoso.',
        toast: 'Sistema Nervoso: esplora le funzioni.',
        legendChips: [],
        build
      };
    })();

    // [Main animation loop and setup code]
    "use strict";
    // Animazione e aggiornamenti della scena
  </script>
</body>
</html>